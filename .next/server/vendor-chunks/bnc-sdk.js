"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bnc-sdk";
exports.ids = ["vendor-chunks/bnc-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/bnc-sdk/dist/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/bnc-sdk/dist/esm/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ \"(ssr)/./node_modules/sturdy-websocket/dist/index.js\");\n/* harmony import */ var crypto_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-es */ \"(ssr)/./node_modules/crypto-es/lib/index.js\");\n/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nanoid */ \"(ssr)/./node_modules/nanoid/index.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/timer.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/merge.js\");\n\n\n\n\nconst networks = {\n  ethereum: {\n    '1': 'main',\n    '5': 'goerli',\n    '100': 'xdai',\n    '137': 'matic-main',\n    '80001': 'matic-mumbai'\n  }\n};\nconst DEPRECATED_NETWORK_IDS = [2, 3, 4, 42, 56, 250];\nconst DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nconst QUEUE_LIMIT = 10000;\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    appVersion,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'appVersion', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'appVersion',\n    value: appVersion,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n\n  if (DEPRECATED_NETWORK_IDS.includes(networkId)) {\n    console.error(`Blocknative SDK: Network with ID: ${networkId} has been deprecated and you will no longer receive transaction events on this network.`);\n  }\n\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'txDropped':\n        case 'txRequest':\n        case 'nsfFail':\n        case 'txRepeat':\n        case 'txAwaitingApproval':\n        case 'txConfirmReminder':\n        case 'txSendFail':\n        case 'txError':\n        case 'txUnderPriced':\n        case 'txPoolSimulation':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://docs.blocknative.com/notify-sdk#event-codes`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    off: function (eventCode) {\n      delete this.listeners[eventCode];\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nconst jsonPreserveUndefined = (k, v) => v === undefined ? 'undefined' : v;\n/**\r\n * Tests if LocalStorage may be used. Accounts for environments where\r\n * LocalStorage is not supported, as well as those where it is blocked.\r\n *\r\n * @returns `true` if LocalStorage is supported and accessible, `false` otherwise.\r\n */\n\n\nfunction isLocalStorageAvailable() {\n  const isSupported = typeof window !== 'undefined' && 'localStorage' in window;\n\n  if (isSupported) {\n    const testKey = '__testLocalStorage';\n\n    try {\n      window.localStorage.setItem(testKey, '1');\n      window.localStorage.removeItem(testKey);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this.watchedTransactions.push({\n    hash,\n    emitter\n  });\n  const transactionId = this._system === 'ethereum' ? {\n    hash\n  } : {\n    txid: hash\n  };\n  const transaction = { ...transactionId,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: newState,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n  const existingAddressWatcher = this.watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this.watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\nvar config = {\n  Promise: undefined,\n\n  set useDeprecatedSynchronousErrorHandling(value) {\n    if (value) {\n      var error = /*@__PURE__*/new Error();\n      /*@__PURE__*/\n\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    }\n\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  }\n\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nfunction hostReportError(err) {\n  setTimeout(function () {\n    throw err;\n  }, 0);\n}\n/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar empty = {\n  closed: true,\n  next: function (value) {},\n  error: function (err) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete: function () {}\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nvar isArray = /*@__PURE__*/function () {\n  return Array.isArray || function (x) {\n    return x && typeof x.length === 'number';\n  };\n}();\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isObject(x) {\n  return x !== null && typeof x === 'object';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar UnsubscriptionErrorImpl = /*@__PURE__*/function () {\n  function UnsubscriptionErrorImpl(errors) {\n    Error.call(this);\n    this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) {\n      return i + 1 + \") \" + err.toString();\n    }).join('\\n  ') : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n    return this;\n  }\n\n  UnsubscriptionErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return UnsubscriptionErrorImpl;\n}();\n\nvar UnsubscriptionError = UnsubscriptionErrorImpl;\n/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */\n\nvar Subscription = /*@__PURE__*/function () {\n  function Subscription(unsubscribe) {\n    this.closed = false;\n    this._parentOrParents = null;\n    this._subscriptions = null;\n\n    if (unsubscribe) {\n      this._ctorUnsubscribe = true;\n      this._unsubscribe = unsubscribe;\n    }\n  }\n\n  Subscription.prototype.unsubscribe = function () {\n    var errors;\n\n    if (this.closed) {\n      return;\n    }\n\n    var _a = this,\n        _parentOrParents = _a._parentOrParents,\n        _ctorUnsubscribe = _a._ctorUnsubscribe,\n        _unsubscribe = _a._unsubscribe,\n        _subscriptions = _a._subscriptions;\n\n    this.closed = true;\n    this._parentOrParents = null;\n    this._subscriptions = null;\n\n    if (_parentOrParents instanceof Subscription) {\n      _parentOrParents.remove(this);\n    } else if (_parentOrParents !== null) {\n      for (var index = 0; index < _parentOrParents.length; ++index) {\n        var parent_1 = _parentOrParents[index];\n        parent_1.remove(this);\n      }\n    }\n\n    if (isFunction(_unsubscribe)) {\n      if (_ctorUnsubscribe) {\n        this._unsubscribe = undefined;\n      }\n\n      try {\n        _unsubscribe.call(this);\n      } catch (e) {\n        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n      var index = -1;\n      var len = _subscriptions.length;\n\n      while (++index < len) {\n        var sub = _subscriptions[index];\n\n        if (isObject(sub)) {\n          try {\n            sub.unsubscribe();\n          } catch (e) {\n            errors = errors || [];\n\n            if (e instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));\n            } else {\n              errors.push(e);\n            }\n          }\n        }\n      }\n    }\n\n    if (errors) {\n      throw new UnsubscriptionError(errors);\n    }\n  };\n\n  Subscription.prototype.add = function (teardown) {\n    var subscription = teardown;\n\n    if (!teardown) {\n      return Subscription.EMPTY;\n    }\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(teardown);\n\n      case 'object':\n        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (!(subscription instanceof Subscription)) {\n          var tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n\n        break;\n\n      default:\n        {\n          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n    }\n\n    var _parentOrParents = subscription._parentOrParents;\n\n    if (_parentOrParents === null) {\n      subscription._parentOrParents = this;\n    } else if (_parentOrParents instanceof Subscription) {\n      if (_parentOrParents === this) {\n        return subscription;\n      }\n\n      subscription._parentOrParents = [_parentOrParents, this];\n    } else if (_parentOrParents.indexOf(this) === -1) {\n      _parentOrParents.push(this);\n    } else {\n      return subscription;\n    }\n\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions === null) {\n      this._subscriptions = [subscription];\n    } else {\n      subscriptions.push(subscription);\n    }\n\n    return subscription;\n  };\n\n  Subscription.prototype.remove = function (subscription) {\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions) {\n      var subscriptionIndex = subscriptions.indexOf(subscription);\n\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  };\n\n  Subscription.EMPTY = function (empty) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription());\n\n  return Subscription;\n}();\n\nfunction flattenUnsubscriptionErrors(errors) {\n  return errors.reduce(function (errs, err) {\n    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);\n  }, []);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar rxSubscriber = /*@__PURE__*/function () {\n  return typeof Symbol === 'function' ? /*@__PURE__*/Symbol('rxSubscriber') : '@@rxSubscriber_' + /*@__PURE__*/Math.random();\n}();\n/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar Subscriber = /*@__PURE__*/function (_super) {\n  __extends(Subscriber, _super);\n\n  function Subscriber(destinationOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this.syncErrorValue = null;\n    _this.syncErrorThrown = false;\n    _this.syncErrorThrowable = false;\n    _this.isStopped = false;\n\n    switch (arguments.length) {\n      case 0:\n        _this.destination = empty;\n        break;\n\n      case 1:\n        if (!destinationOrNext) {\n          _this.destination = empty;\n          break;\n        }\n\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            _this.destination = destinationOrNext;\n            destinationOrNext.add(_this);\n          } else {\n            _this.syncErrorThrowable = true;\n            _this.destination = new SafeSubscriber(_this, destinationOrNext);\n          }\n\n          break;\n        }\n\n      default:\n        _this.syncErrorThrowable = true;\n        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n        break;\n    }\n\n    return _this;\n  }\n\n  Subscriber.prototype[rxSubscriber] = function () {\n    return this;\n  };\n\n  Subscriber.create = function (next, error, complete) {\n    var subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  };\n\n  Subscriber.prototype.next = function (value) {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  };\n\n  Subscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  };\n\n  Subscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  };\n\n  Subscriber.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.isStopped = true;\n\n    _super.prototype.unsubscribe.call(this);\n  };\n\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n\n  Subscriber.prototype._error = function (err) {\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._complete = function () {\n    this.destination.complete();\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._unsubscribeAndRecycle = function () {\n    var _parentOrParents = this._parentOrParents;\n    this._parentOrParents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parentOrParents = _parentOrParents;\n    return this;\n  };\n\n  return Subscriber;\n}(Subscription);\n\nvar SafeSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SafeSubscriber, _super);\n\n  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this._parentSubscriber = _parentSubscriber;\n    var next;\n    var context = _this;\n\n    if (isFunction(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      next = observerOrNext.next;\n      error = observerOrNext.error;\n      complete = observerOrNext.complete;\n\n      if (observerOrNext !== empty) {\n        context = Object.create(observerOrNext);\n\n        if (isFunction(context.unsubscribe)) {\n          _this.add(context.unsubscribe.bind(context));\n        }\n\n        context.unsubscribe = _this.unsubscribe.bind(_this);\n      }\n    }\n\n    _this._context = context;\n    _this._next = next;\n    _this._error = error;\n    _this._complete = complete;\n    return _this;\n  }\n\n  SafeSubscriber.prototype.next = function (value) {\n    if (!this.isStopped && this._next) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;\n\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.complete = function () {\n    var _this = this;\n\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._complete) {\n        var wrappedComplete = function () {\n          return _this._complete.call(_this._context);\n        };\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  SafeSubscriber.prototype._unsubscribe = function () {\n    var _parentSubscriber = this._parentSubscriber;\n    this._context = null;\n    this._parentSubscriber = null;\n\n    _parentSubscriber.unsubscribe();\n  };\n\n  return SafeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */\n\n\nfunction canReportError(observer) {\n  while (observer) {\n    var _a = observer,\n        closed_1 = _a.closed,\n        destination = _a.destination,\n        isStopped = _a.isStopped;\n\n    if (closed_1 || isStopped) {\n      return false;\n    } else if (destination && destination instanceof Subscriber) {\n      observer = destination;\n    } else {\n      observer = null;\n    }\n  }\n\n  return true;\n}\n/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\n\n\nfunction toSubscriber(nextOrObserver, error, complete) {\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return nextOrObserver;\n    }\n\n    if (nextOrObserver[rxSubscriber]) {\n      return nextOrObserver[rxSubscriber]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(empty);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar observable = /*@__PURE__*/function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n}();\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction identity(x) {\n  return x;\n}\n/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */\n\n\nfunction pipeFromArray(fns) {\n  if (fns.length === 0) {\n    return identity;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input) {\n    return fns.reduce(function (prev, fn) {\n      return fn(prev);\n    }, input);\n  };\n}\n/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\n\n\nvar Observable = /*@__PURE__*/function () {\n  function Observable(subscribe) {\n    this._isScalar = false;\n\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  Observable.prototype.lift = function (operator) {\n    var observable = new Observable();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  };\n\n  Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n    var operator = this.operator;\n    var sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      sink.add(operator.call(sink, this.source));\n    } else {\n      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  };\n\n  Observable.prototype._trySubscribe = function (sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  };\n\n  Observable.prototype.forEach = function (next, promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var subscription;\n      subscription = _this.subscribe(function (value) {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    });\n  };\n\n  Observable.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n    return source && source.subscribe(subscriber);\n  };\n\n  Observable.prototype[observable] = function () {\n    return this;\n  };\n\n  Observable.prototype.pipe = function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i] = arguments[_i];\n    }\n\n    if (operations.length === 0) {\n      return this;\n    }\n\n    return pipeFromArray(operations)(this);\n  };\n\n  Observable.prototype.toPromise = function (promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var value;\n\n      _this.subscribe(function (x) {\n        return value = x;\n      }, function (err) {\n        return reject(err);\n      }, function () {\n        return resolve(value);\n      });\n    });\n  };\n\n  Observable.create = function (subscribe) {\n    return new Observable(subscribe);\n  };\n\n  return Observable;\n}();\n\nfunction getPromiseCtor(promiseCtor) {\n  if (!promiseCtor) {\n    promiseCtor = Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar subscribeToArray = function (array) {\n  return function (subscriber) {\n    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n\n    subscriber.complete();\n  };\n};\n/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\n\n\nvar subscribeToPromise = function (promise) {\n  return function (subscriber) {\n    promise.then(function (value) {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    }, function (err) {\n      return subscriber.error(err);\n    }).then(null, hostReportError);\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction getSymbolIterator() {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator';\n  }\n\n  return Symbol.iterator;\n}\n\nvar iterator = /*@__PURE__*/getSymbolIterator();\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n\nvar subscribeToIterable = function (iterable) {\n  return function (subscriber) {\n    var iterator$1 = iterable[iterator]();\n\n    do {\n      var item = void 0;\n\n      try {\n        item = iterator$1.next();\n      } catch (err) {\n        subscriber.error(err);\n        return subscriber;\n      }\n\n      if (item.done) {\n        subscriber.complete();\n        break;\n      }\n\n      subscriber.next(item.value);\n\n      if (subscriber.closed) {\n        break;\n      }\n    } while (true);\n\n    if (typeof iterator$1.return === 'function') {\n      subscriber.add(function () {\n        if (iterator$1.return) {\n          iterator$1.return();\n        }\n      });\n    }\n\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeToObservable = function (obj) {\n  return function (subscriber) {\n    var obs = obj[observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    } else {\n      return obs.subscribe(subscriber);\n    }\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar isArrayLike = function (x) {\n  return x && typeof x.length === 'number' && typeof x !== 'function';\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isPromise(value) {\n  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeTo = function (result) {\n  if (!!result && typeof result[observable] === 'function') {\n    return subscribeToObservable(result);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result);\n  } else if (!!result && typeof result[iterator] === 'function') {\n    return subscribeToIterable(result);\n  } else {\n    var value = isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */\n\n\nvar SimpleInnerSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SimpleInnerSubscriber, _super);\n\n  function SimpleInnerSubscriber(parent) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent;\n    return _this;\n  }\n\n  SimpleInnerSubscriber.prototype._next = function (value) {\n    this.parent.notifyNext(value);\n  };\n\n  SimpleInnerSubscriber.prototype._error = function (error) {\n    this.parent.notifyError(error);\n    this.unsubscribe();\n  };\n\n  SimpleInnerSubscriber.prototype._complete = function () {\n    this.parent.notifyComplete();\n    this.unsubscribe();\n  };\n\n  return SimpleInnerSubscriber;\n}(Subscriber);\n\nvar SimpleOuterSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SimpleOuterSubscriber, _super);\n\n  function SimpleOuterSubscriber() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {\n    this.destination.next(innerValue);\n  };\n\n  SimpleOuterSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  SimpleOuterSubscriber.prototype.notifyComplete = function () {\n    this.destination.complete();\n  };\n\n  return SimpleOuterSubscriber;\n}(Subscriber);\n\nfunction innerSubscribe(result, innerSubscriber) {\n  if (innerSubscriber.closed) {\n    return undefined;\n  }\n\n  if (result instanceof Observable) {\n    return result.subscribe(innerSubscriber);\n  }\n\n  return subscribeTo(result)(innerSubscriber);\n}\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\n\nvar Action = /*@__PURE__*/function (_super) {\n  __extends(Action, _super);\n\n  function Action(scheduler, work) {\n    return _super.call(this) || this;\n  }\n\n  Action.prototype.schedule = function (state, delay) {\n    return this;\n  };\n\n  return Action;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\n\n\nvar AsyncAction = /*@__PURE__*/function (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n\n    clearInterval(id);\n    return undefined;\n  };\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action);\n\nvar Scheduler = /*@__PURE__*/function () {\n  function Scheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    this.SchedulerAction = SchedulerAction;\n    this.now = now;\n  }\n\n  Scheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return new this.SchedulerAction(this, work).schedule(state, delay);\n  };\n\n  Scheduler.now = function () {\n    return Date.now();\n  };\n\n  return Scheduler;\n}();\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\n\n\nvar AsyncScheduler = /*@__PURE__*/function (_super) {\n  __extends(AsyncScheduler, _super);\n\n  function AsyncScheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    var _this = _super.call(this, SchedulerAction, function () {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    }) || this;\n\n    _this.actions = [];\n    _this.active = false;\n    _this.scheduled = undefined;\n    return _this;\n  }\n\n  AsyncScheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return _super.prototype.schedule.call(this, work, delay, state);\n    }\n  };\n\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    var error;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift());\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsyncScheduler;\n}(Scheduler);\n/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\n\n\nvar asyncScheduler = /*@__PURE__*/new AsyncScheduler(AsyncAction);\nvar async = asyncScheduler;\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nfunction isDate(value) {\n  return value instanceof Date && !isNaN(+value);\n}\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nvar EMPTY = /*@__PURE__*/new Observable(function (subscriber) {\n  return subscriber.complete();\n});\n\nfunction empty$1(scheduler) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler) {\n  return new Observable(function (subscriber) {\n    return scheduler.schedule(function () {\n      return subscriber.complete();\n    });\n  });\n}\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nfunction throwError(error, scheduler) {\n  if (!scheduler) {\n    return new Observable(function (subscriber) {\n      return subscriber.error(error);\n    });\n  } else {\n    return new Observable(function (subscriber) {\n      return scheduler.schedule(dispatch, 0, {\n        error: error,\n        subscriber: subscriber\n      });\n    });\n  }\n}\n\nfunction dispatch(_a) {\n  var error = _a.error,\n      subscriber = _a.subscriber;\n  subscriber.error(error);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar ArgumentOutOfRangeErrorImpl = /*@__PURE__*/function () {\n  function ArgumentOutOfRangeErrorImpl() {\n    Error.call(this);\n    this.message = 'argument out of range';\n    this.name = 'ArgumentOutOfRangeError';\n    return this;\n  }\n\n  ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return ArgumentOutOfRangeErrorImpl;\n}();\n\nvar ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\nfunction filter(predicate, thisArg) {\n  return function filterOperatorFunction(source) {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nvar FilterOperator = /*@__PURE__*/function () {\n  function FilterOperator(predicate, thisArg) {\n    this.predicate = predicate;\n    this.thisArg = thisArg;\n  }\n\n  FilterOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  };\n\n  return FilterOperator;\n}();\n\nvar FilterSubscriber = /*@__PURE__*/function (_super) {\n  __extends(FilterSubscriber, _super);\n\n  function FilterSubscriber(destination, predicate, thisArg) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.thisArg = thisArg;\n    _this.count = 0;\n    return _this;\n  }\n\n  FilterSubscriber.prototype._next = function (value) {\n    var result;\n\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    if (result) {\n      this.destination.next(value);\n    }\n  };\n\n  return FilterSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\n\n\nfunction take(count) {\n  return function (source) {\n    if (count === 0) {\n      return empty$1();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nvar TakeOperator = /*@__PURE__*/function () {\n  function TakeOperator(total) {\n    this.total = total;\n\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n\n  TakeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  };\n\n  return TakeOperator;\n}();\n\nvar TakeSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TakeSubscriber, _super);\n\n  function TakeSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.count = 0;\n    return _this;\n  }\n\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n\n    if (count <= total) {\n      this.destination.next(value);\n\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n\n  return TakeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */\n\n\nfunction finalize(callback) {\n  return function (source) {\n    return source.lift(new FinallyOperator(callback));\n  };\n}\n\nvar FinallyOperator = /*@__PURE__*/function () {\n  function FinallyOperator(callback) {\n    this.callback = callback;\n  }\n\n  FinallyOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n  };\n\n  return FinallyOperator;\n}();\n\nvar FinallySubscriber = /*@__PURE__*/function (_super) {\n  __extends(FinallySubscriber, _super);\n\n  function FinallySubscriber(destination, callback) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.add(new Subscription(callback));\n\n    return _this;\n  }\n\n  return FinallySubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\n\n\nfunction takeWhile(predicate, inclusive) {\n  if (inclusive === void 0) {\n    inclusive = false;\n  }\n\n  return function (source) {\n    return source.lift(new TakeWhileOperator(predicate, inclusive));\n  };\n}\n\nvar TakeWhileOperator = /*@__PURE__*/function () {\n  function TakeWhileOperator(predicate, inclusive) {\n    this.predicate = predicate;\n    this.inclusive = inclusive;\n  }\n\n  TakeWhileOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n  };\n\n  return TakeWhileOperator;\n}();\n\nvar TakeWhileSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TakeWhileSubscriber, _super);\n\n  function TakeWhileSubscriber(destination, predicate, inclusive) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.predicate = predicate;\n    _this.inclusive = inclusive;\n    _this.index = 0;\n    return _this;\n  }\n\n  TakeWhileSubscriber.prototype._next = function (value) {\n    var destination = this.destination;\n    var result;\n\n    try {\n      result = this.predicate(value, this.index++);\n    } catch (err) {\n      destination.error(err);\n      return;\n    }\n\n    this.nextOrComplete(value, result);\n  };\n\n  TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n    var destination = this.destination;\n\n    if (Boolean(predicateResult)) {\n      destination.next(value);\n    } else {\n      if (this.inclusive) {\n        destination.next(value);\n      }\n\n      destination.complete();\n    }\n  };\n\n  return TakeWhileSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar TimeoutErrorImpl = /*@__PURE__*/function () {\n  function TimeoutErrorImpl() {\n    Error.call(this);\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    return this;\n  }\n\n  TimeoutErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return TimeoutErrorImpl;\n}();\n\nvar TimeoutError = TimeoutErrorImpl;\n/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */\n\nfunction timeoutWith(due, withObservable, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return function (source) {\n    var absoluteTimeout = isDate(due);\n    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nvar TimeoutWithOperator = /*@__PURE__*/function () {\n  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n  }\n\n  TimeoutWithOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n  };\n\n  return TimeoutWithOperator;\n}();\n\nvar TimeoutWithSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TimeoutWithSubscriber, _super);\n\n  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.absoluteTimeout = absoluteTimeout;\n    _this.waitFor = waitFor;\n    _this.withObservable = withObservable;\n    _this.scheduler = scheduler;\n\n    _this.scheduleTimeout();\n\n    return _this;\n  }\n\n  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n    var withObservable = subscriber.withObservable;\n\n    subscriber._unsubscribeAndRecycle();\n\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  };\n\n  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutWithSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n\n  TimeoutWithSubscriber.prototype._unsubscribe = function () {\n    this.action = undefined;\n    this.scheduler = null;\n    this.withObservable = null;\n  };\n\n  return TimeoutWithSubscriber;\n}(SimpleOuterSubscriber);\n/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */\n\n\nfunction timeout(due, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}\n\nconst simulations$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n\nfunction simulate(system, network, transaction) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const id = (0,nanoid__WEBPACK_IMPORTED_MODULE_3__.nanoid)(); // send payload to server\n\n  this._sendMessage({\n    categoryCode: 'simulate',\n    eventCode: 'txSimulation',\n    eventId: id,\n    transaction: transaction\n  });\n\n  return new Promise((resolve, reject) => {\n    simulations$.pipe(filter(({\n      eventId\n    }) => {\n      return eventId === id;\n    }), take(1)).subscribe({\n      next: ({\n        transaction\n      }) => resolve(transaction),\n      error: ({\n        error\n      }) => reject(error.message)\n    });\n  });\n}\n\nfunction multiSim(transactions) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const id = (0,nanoid__WEBPACK_IMPORTED_MODULE_3__.nanoid)(); // send payload to server\n\n  this._sendMessage({\n    categoryCode: 'simulate',\n    eventCode: 'txSimulation',\n    eventId: id,\n    transaction: transactions\n  });\n\n  return new Promise((resolve, reject) => {\n    simulations$.pipe(filter(({\n      eventId\n    }) => {\n      return eventId === id;\n    }), take(1)).subscribe({\n      next: ({\n        transaction\n      }) => resolve(transaction),\n      error: ({\n        error\n      }) => reject(error.message)\n    });\n  });\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this.watchedAccounts = this.watchedAccounts.filter(ac => ac.address !== normalizedAddress); // remove configuration from memory\n\n    this.configurations.delete(normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this.watchedTransactions = this.watchedTransactions.filter(tx => tx.hash !== addressOrHash);\n    const transactionId = this._system === 'ethereum' ? {\n      hash: addressOrHash\n    } : {\n      txid: addressOrHash\n    };\n    const transaction = { ...transactionId,\n      id: addressOrHash,\n      status: 'unsubscribed'\n    }; // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n\nfunction configuration(config) {\n  if (this._destroyed) {\n    throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  }\n\n  const casedScope = this._system === 'ethereum' ? config.scope.toLowerCase() : config.scope; // resolve previous configuration if exists\n\n  const previousConfiguration = this.configurations.get(casedScope);\n  previousConfiguration && previousConfiguration.subscription && previousConfiguration.subscription.next();\n  const subscription = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject(); // create emitter for transaction\n\n  const emitter = config.watchAddress ? {\n    emitter: createEmitter()\n  } : {};\n  this.configurations.set(casedScope, { ...config,\n    ...emitter,\n    subscription\n  });\n\n  this._sendMessage({\n    categoryCode: 'configs',\n    eventCode: 'put',\n    config\n  });\n\n  return new Promise((resolve, reject) => {\n    subscription.pipe(take(1), timeout(5000)).subscribe({\n      next: () => resolve({ ...emitter,\n        details: {\n          config\n        }\n      }),\n      error: error => {\n        const message = error.message === 'Timeout has occurred' ? `Configuration with scope: ${config.scope} has been sent to the Blocknative server, but has not received a reply within 5 seconds.` : error.message;\n\n        if (this._onerror) {\n          this._onerror({\n            message\n          });\n\n          resolve(`Error: ${message}`);\n        } else {\n          reject(message);\n        }\n      }\n    });\n  });\n}\n\nfunction subscribe(subscription) {\n  const {\n    id,\n    chainId,\n    type\n  } = subscription;\n\n  if (!networkName('ethereum', parseInt(chainId, 16))) {\n    throw new Error(`chainId: ${chainId} is an unsupported network`);\n  }\n\n  if (!this.connections[chainId]) {\n    this.connections[chainId] = new this.Blocknative({\n      system: 'ethereum',\n      networkId: parseInt(chainId, 16),\n      dappId: this.apiKey,\n      ws: this.ws,\n      apiUrl: this.apiUrl,\n      transactionHandlers: [({\n        transaction\n      }) => {\n        this.onTransaction$.next(transaction);\n      }],\n      onerror: error => this.errors$.next(error)\n    });\n  }\n\n  const sdk = this.connections[chainId];\n\n  if (type === 'account') {\n    const {\n      filters = [],\n      abi\n    } = subscription;\n    sdk.configuration({\n      scope: id,\n      filters,\n      ...(abi ? {\n        abi\n      } : {}),\n      watchAddress: true\n    });\n    return this.transactions$.pipe(filter(({\n      watchedAddress\n    }) => watchedAddress === id), finalize(() => {\n      this.unsubscribe({\n        id,\n        chainId\n      });\n    }));\n  } else {\n    const {\n      emitter\n    } = sdk.transaction(id);\n    return (0,rxjs__WEBPACK_IMPORTED_MODULE_4__.fromEvent)( // eslint-disable-next-line\n    // @ts-ignore - string does not match specific eventcode string\n    emitter, 'all').pipe( // automatically complete stream on a finalized status\n    takeWhile(({\n      status\n    }) => status !== 'confirmed' && status !== 'failed' && status !== 'dropped', true), // cleanup subscription and SDK on completion\n    finalize(() => {\n      this.unsubscribe({\n        id,\n        chainId\n      });\n    }));\n  }\n}\n\nfunction unsubscribe$1(options) {\n  const {\n    id,\n    chainId,\n    timeout = 0\n  } = options;\n  const time$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_5__.timer)(timeout);\n  const transactionEvent$ = this.transactions$.pipe(filter(({\n    hash,\n    watchedAddress\n  }) => hash === id || watchedAddress === id));\n  (0,rxjs__WEBPACK_IMPORTED_MODULE_6__.merge)(transactionEvent$, time$).pipe(take(1)) // take just first event\n  .subscribe(res => {\n    // if number, then timeout with no transaction events, so go ahead and unsub\n    if (typeof res === 'number') {\n      const sdkConnections = Object.entries(this.connections).filter(([chainId, sdk]) => sdk !== null);\n      sdkConnections.forEach(([connectionChainId, sdk]) => {\n        // if chainId is passed and it doesn't match, then no unsub (return early)\n        if (chainId && connectionChainId !== chainId) return;\n        sdk.unsubscribe(id); // if no remaining subscriptions, destroy connection and set to null\n\n        if (!sdk.watchedAccounts.length && !sdk.watchedTransactions.length && !sdk.configurations.size) {\n          sdk.destroy();\n          this.connections[connectionChainId] = null;\n        }\n      });\n    } else {\n      // otherwise a transaction event received, so call unsub again for another timeout\n      this.unsubscribe(options);\n    }\n  });\n} //**Experimental API that is not yet finalized and is in BETA*/\n\n\nclass MultiChain {\n  constructor(options, Blocknative) {\n    const {\n      ws\n    } = options;\n    const {\n      apiKey\n    } = options;\n    const {\n      apiUrl\n    } = options;\n    this.apiKey = apiKey;\n    this.apiUrl = apiUrl;\n    this.ws = ws;\n    this.connections = {};\n    this.onTransaction$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n    this.transactions$ = this.onTransaction$.asObservable();\n    this.errors$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n    this.Blocknative = Blocknative;\n    this.subscribe = subscribe.bind(this);\n    this.unsubscribe = unsubscribe$1.bind(this);\n  }\n\n}\n\nvar version = \"4.6.7\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nasync function processQueue() {\n  this._processingQueue = true;\n\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  while (this._queuedMessages.length > 0) {\n    // small wait to allow response from server to take affect\n    await wait(1);\n\n    if (this._waitToRetry !== null) {\n      // have been rate limited so wait\n      await this._waitToRetry;\n      this._waitToRetry = null;\n    }\n\n    const msg = this._queuedMessages.shift();\n\n    const delay = this._limitRules.duration / this._limitRules.points * 1000;\n    await wait(delay);\n\n    this._socket.send(msg);\n  }\n\n  this._processingQueue = false;\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId,\n    serverVersion,\n    retryMs,\n    limitRules,\n    blockedMsg,\n    dispatchTimestamp\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (isLocalStorageAvailable()) {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit') && !reason.match(/IP (PendingSimulation|Notification) ratelimit reached/)) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('upgrade your plan')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (event && event.categoryCode === 'simulate') {\n      simulations$.error({\n        eventId: event.eventId,\n        error: {\n          message: reason\n        }\n      });\n      return;\n    } // handle config error\n\n\n    if (event && event.config) {\n      const configuration = this.configurations.get(event.config.scope);\n\n      if (configuration && configuration.subscription) {\n        configuration.subscription.error({\n          message: reason\n        });\n      }\n\n      return;\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.config) {\n    const casedScope = this._system === 'ethereum' ? event.config.scope.toLowerCase() : event.config.scope;\n    const configuration = this.configurations.get(casedScope);\n\n    if (configuration && configuration.subscription) {\n      configuration.subscription.next();\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      eventId,\n      transaction,\n      eventCode,\n      contractCall,\n      timeStamp,\n      blockchain: {\n        system,\n        network\n      }\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      serverVersion,\n      eventCode,\n      timeStamp,\n      dispatchTimestamp,\n      system,\n      network,\n      contractCall\n    } : { ...transaction,\n      serverVersion,\n      eventCode,\n      timeStamp,\n      dispatchTimestamp,\n      system,\n      network\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // replace originalHash to match webhook API\n\n\n    if (newState.originalHash) {\n      newState.replaceHash = newState.hash;\n      newState.hash = newState.originalHash;\n      delete newState.originalHash;\n    } // replace status to match webhook API\n\n\n    if (eventCode === 'txSpeedUp' && newState.status !== 'speedup') {\n      newState.status = 'speedup';\n    } // replace status to match webhook API\n\n\n    if (eventCode === 'txCancel' && newState.status !== 'cancel') {\n      newState.status = 'cancel';\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this.watchedTransactions = this.watchedTransactions.map(tx => {\n        if (tx.hash === newState.replaceHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    if (event && event.categoryCode === 'simulate') {\n      newState.contractCall = event.transaction.contractCall;\n      delete newState.dispatchTimestamp;\n      simulations$.next({\n        eventId,\n        transaction: newState\n      });\n      return;\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this.watchedAccounts.find(ac => ac.address === watchedAddress);\n      const accountEmitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n      const configuration = this.configurations.get(watchedAddress);\n      const emitterResult = configuration && configuration.emitter ? configuration.emitter.emit(newState) || accountEmitterResult : accountEmitterResult;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this.watchedTransactions.find(tx => tx.hash === newState.hash || newState.txid);\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      })); // replace the emitter hash to the replace hash on replacement txs\n\n\n      if (newState.status === 'speedup' || newState.status === 'cancel') {\n        this.watchedTransactions = this.watchedTransactions.map(tx => {\n          if (tx.hash === newState.hash || newState.txid) {\n            return { ...tx,\n              hash: newState.replaceHash\n            };\n          }\n\n          return tx;\n        });\n      }\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date().toISOString(),\n    dappId: this._dappId,\n    version,\n    appName: this._appName,\n    appVersion: this._appVersion,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  }, msg.categoryCode === 'configs' ? jsonPreserveUndefined : undefined);\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nconst DEFAULT_APP_NAME = 'unknown';\nconst DEFAULT_APP_VERSION = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass SDK {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_APP_NAME,\n      appVersion = DEFAULT_APP_VERSION,\n      networkId,\n      transactionHandlers = [],\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const {\n      apiUrl\n    } = options;\n    const {\n      dappId\n    } = options; // override default timeout to allow for slow connections\n\n    const timeout = {\n      connectTimeout: 10000\n    };\n    const socket = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__[\"default\"](apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws,\n      ...timeout\n    } : { ...timeout\n    });\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = crypto_es__WEBPACK_IMPORTED_MODULE_1__[\"default\"].SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = isLocalStorageAvailable() && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._appName = name;\n    this._appVersion = appVersion;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n    this._queuedMessages = [];\n    this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n    this._waitToRetry = null;\n    this._processingQueue = false;\n    this._processQueue = processQueue.bind(this);\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.watchedTransactions = [];\n    this.watchedAccounts = [];\n    this.configurations = new Map();\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.simulate = simulate.bind(this);\n    this.multiSim = multiSim.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n    this.configuration = configuration.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n  static multichain(options) {\n    return new MultiChain(options, this);\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nasync function onReopen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all configurations on re-connection\n\n\n  const configurations = Array.from(this.configurations.values()); // register global config first and wait for it to complete\n\n  const globalConfiguration = this.configurations.get('global');\n\n  if (globalConfiguration) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {\n        emitter,\n        subscription,\n        ...config\n      } = globalConfiguration;\n      await this.configuration(config);\n    } catch (error) {\n      console.warn('Error re-sending global configuration upon reconnection:', error);\n    }\n  }\n\n  const addressConfigurations = configurations.filter(({\n    scope\n  }) => scope !== 'global');\n  addressConfigurations.forEach(enhancedConfig => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      emitter,\n      subscription,\n      ...config\n    } = enhancedConfig;\n\n    this._sendMessage({\n      categoryCode: 'configs',\n      eventCode: 'put',\n      config\n    });\n  }); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n  this.watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws && this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SDK);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYm5jLXNkay9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQztBQUNkO0FBQ0Q7QUFDd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLHdCQUF3QixLQUFLO0FBQzdCOztBQUVBO0FBQ0Esd0JBQXdCLEtBQUsscUJBQXFCLEtBQUssbUJBQW1CLGNBQWMsY0FBYyxNQUFNO0FBQzVHOztBQUVBO0FBQ0Esd0JBQXdCLE1BQU0sb0JBQW9CLEtBQUs7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx1REFBdUQsV0FBVztBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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QUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0I7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDs7O0FBR3JELG1FQUFtRTs7QUFFbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLEdBQUc7QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsR0FBRyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vem9yby8uL25vZGVfbW9kdWxlcy9ibmMtc2RrL2Rpc3QvZXNtL2luZGV4LmpzPzg1YzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0dXJkeVdlYlNvY2tldCBmcm9tICdzdHVyZHktd2Vic29ja2V0JztcbmltcG9ydCBDcnlwdG9FcyBmcm9tICdjcnlwdG8tZXMnO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnbmFub2lkJztcbmltcG9ydCB7IFN1YmplY3QsIGZyb21FdmVudCwgdGltZXIsIG1lcmdlIH0gZnJvbSAncnhqcyc7XG5jb25zdCBuZXR3b3JrcyA9IHtcbiAgZXRoZXJldW06IHtcbiAgICAnMSc6ICdtYWluJyxcbiAgICAnNSc6ICdnb2VybGknLFxuICAgICcxMDAnOiAneGRhaScsXG4gICAgJzEzNyc6ICdtYXRpYy1tYWluJyxcbiAgICAnODAwMDEnOiAnbWF0aWMtbXVtYmFpJ1xuICB9XG59O1xuY29uc3QgREVQUkVDQVRFRF9ORVRXT1JLX0lEUyA9IFsyLCAzLCA0LCA0MiwgNTYsIDI1MF07XG5jb25zdCBERUZBVUxUX1JBVEVfTElNSVRfUlVMRVMgPSB7XG4gIHBvaW50czogMTUwLFxuICBkdXJhdGlvbjogMVxufTtcbmNvbnN0IFFVRVVFX0xJTUlUID0gMTAwMDA7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIHR5cGUsXG4gICAgb3B0aW9uYWwsXG4gICAgY3VzdG9tVmFsaWRhdGlvblxuICB9ID0gb3B0aW9ucztcblxuICBpZiAoIW9wdGlvbmFsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIGlzIHJlcXVpcmVkYCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZSA9PT0gJ2FycmF5JyA/IEFycmF5LmlzQXJyYXkodHlwZSkgOiB0eXBlb2YgdmFsdWUgIT09IHR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIG9mIHR5cGU6ICR7dHlwZX0sIHJlY2VpdmVkIHR5cGU6ICR7dHlwZW9mIHZhbHVlfSBmcm9tIHZhbHVlOiAke3ZhbHVlfWApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY3VzdG9tVmFsaWRhdGlvbiAmJiAhY3VzdG9tVmFsaWRhdGlvbih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt2YWx1ZX1cIiBpcyBub3QgYSB2YWxpZCBcIiR7bmFtZX1cImApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3NkayBvcHRpb25zJyxcbiAgICB2YWx1ZTogb3B0aW9ucyxcbiAgICB0eXBlOiAnb2JqZWN0J1xuICB9KTtcbiAgY29uc3Qge1xuICAgIGRhcHBJZCxcbiAgICBzeXN0ZW0sXG4gICAgbmFtZSxcbiAgICBhcHBWZXJzaW9uLFxuICAgIG5ldHdvcmtJZCxcbiAgICB0cmFuc2FjdGlvbkhhbmRsZXJzLFxuICAgIGFwaVVybCxcbiAgICB3cyxcbiAgICBvbm9wZW4sXG4gICAgb25kb3duLFxuICAgIG9ucmVvcGVuLFxuICAgIG9uZXJyb3IsXG4gICAgb25jbG9zZSxcbiAgICAuLi5vdGhlclBhcmFtc1xuICB9ID0gb3B0aW9ucztcbiAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWydkYXBwSWQnLCAnc3lzdGVtJywgJ25hbWUnLCAnYXBwVmVyc2lvbicsICduZXR3b3JrSWQnLCAndHJhbnNhY3Rpb25IYW5kbGVycycsICdhcGlVcmwnLCAnd3MnLCAnb25vcGVuJywgJ29uZG93bicsICdvbnJlb3BlbicsICdvbmVycm9yJywgJ29uY2xvc2UnXSwgJ0luaXRpYWxpemF0aW9uIE9wdGlvbnMnKTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnZGFwcElkJyxcbiAgICB2YWx1ZTogZGFwcElkLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdzeXN0ZW0nLFxuICAgIHZhbHVlOiBzeXN0ZW0sXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWUsXG4gICAgY3VzdG9tVmFsaWRhdGlvbjogdmFsaWRTeXN0ZW1cbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ25hbWUnLFxuICAgIHZhbHVlOiBuYW1lLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdhcHBWZXJzaW9uJyxcbiAgICB2YWx1ZTogYXBwVmVyc2lvbixcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmV0d29ya0lkJyxcbiAgICB2YWx1ZTogbmV0d29ya0lkLFxuICAgIHR5cGU6ICdudW1iZXInXG4gIH0pO1xuXG4gIGlmIChERVBSRUNBVEVEX05FVFdPUktfSURTLmluY2x1ZGVzKG5ldHdvcmtJZCkpIHtcbiAgICBjb25zb2xlLmVycm9yKGBCbG9ja25hdGl2ZSBTREs6IE5ldHdvcmsgd2l0aCBJRDogJHtuZXR3b3JrSWR9IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHlvdSB3aWxsIG5vIGxvbmdlciByZWNlaXZlIHRyYW5zYWN0aW9uIGV2ZW50cyBvbiB0aGlzIG5ldHdvcmsuYCk7XG4gIH1cblxuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd0cmFuc2FjdGlvbkhhbmRsZXInLFxuICAgIHZhbHVlOiB0cmFuc2FjdGlvbkhhbmRsZXJzLFxuICAgIHR5cGU6ICdhcnJheScsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHRyYW5zYWN0aW9uSGFuZGxlcnMpIHtcbiAgICB0cmFuc2FjdGlvbkhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ3RyYW5zYWN0aW9uSGFuZGxlcicsXG4gICAgICB2YWx1ZTogaGFuZGxlcixcbiAgICAgIHR5cGU6ICdmdW5jdGlvbidcbiAgICB9KSk7XG4gIH1cblxuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdhcGlVcmwnLFxuICAgIHZhbHVlOiBhcGlVcmwsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dzJyxcbiAgICB2YWx1ZTogd3MsXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25vcGVuJyxcbiAgICB2YWx1ZTogb25vcGVuLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29uZG93bicsXG4gICAgdmFsdWU6IG9uZG93bixcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdvbnJlb3BlbicsXG4gICAgdmFsdWU6IG9ucmVvcGVuLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29uZXJyb3InLFxuICAgIHZhbHVlOiBvbmVycm9yLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29uY2xvc2UnLFxuICAgIHZhbHVlOiBvbmNsb3NlLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkU3lzdGVtKHN5c3RlbSkge1xuICByZXR1cm4gISFuZXR3b3Jrc1tzeXN0ZW1dO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkUGFyYW1zKHBhcmFtcywgdmFsaWRQYXJhbXMsIGZ1bmN0aW9uTmFtZSkge1xuICBjb25zdCBpbnZhbGlkID0gT2JqZWN0LmtleXMocGFyYW1zKTtcblxuICBpZiAoaW52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2ludmFsaWRbMF19IGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlciBmb3IgJHtmdW5jdGlvbk5hbWV9LCBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbGlkIHBhcmFtZXRlcnM6ICR7dmFsaWRQYXJhbXMuam9pbignLCAnKX1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICByZXR1cm4ge1xuICAgIGxpc3RlbmVyczoge30sXG4gICAgb246IGZ1bmN0aW9uIChldmVudENvZGUsIGxpc3RlbmVyKSB7XG4gICAgICAvLyBjaGVjayBpZiB2YWxpZCBldmVudENvZGVcbiAgICAgIHN3aXRjaCAoZXZlbnRDb2RlKSB7XG4gICAgICAgIGNhc2UgJ3R4U2VudCc6XG4gICAgICAgIGNhc2UgJ3R4UG9vbCc6XG4gICAgICAgIGNhc2UgJ3R4Q29uZmlybWVkJzpcbiAgICAgICAgY2FzZSAndHhTcGVlZFVwJzpcbiAgICAgICAgY2FzZSAndHhDYW5jZWwnOlxuICAgICAgICBjYXNlICd0eEZhaWxlZCc6XG4gICAgICAgIGNhc2UgJ3R4RHJvcHBlZCc6XG4gICAgICAgIGNhc2UgJ3R4UmVxdWVzdCc6XG4gICAgICAgIGNhc2UgJ25zZkZhaWwnOlxuICAgICAgICBjYXNlICd0eFJlcGVhdCc6XG4gICAgICAgIGNhc2UgJ3R4QXdhaXRpbmdBcHByb3ZhbCc6XG4gICAgICAgIGNhc2UgJ3R4Q29uZmlybVJlbWluZGVyJzpcbiAgICAgICAgY2FzZSAndHhTZW5kRmFpbCc6XG4gICAgICAgIGNhc2UgJ3R4RXJyb3InOlxuICAgICAgICBjYXNlICd0eFVuZGVyUHJpY2VkJzpcbiAgICAgICAgY2FzZSAndHhQb29sU2ltdWxhdGlvbic6XG4gICAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXZlbnRDb2RlfSBpcyBub3QgYSB2YWxpZCBldmVudCBjb2RlLCBmb3IgYSBsaXN0IG9mIHZhbGlkIGV2ZW50IGNvZGVzIHNlZTogaHR0cHM6Ly9kb2NzLmJsb2NrbmF0aXZlLmNvbS9ub3RpZnktc2RrI2V2ZW50LWNvZGVzYCk7XG4gICAgICB9IC8vIGNoZWNrIHRoYXQgbGlzdGVuZXIgaXMgYSBmdW5jdGlvblxuXG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIH0gLy8gYWRkIGxpc3RlbmVyIGZvciB0aGUgZXZlbnRDb2RlXG5cblxuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRDb2RlXSA9IGxpc3RlbmVyO1xuICAgIH0sXG4gICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnRDb2RlKSB7XG4gICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbZXZlbnRDb2RlXTtcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW3N0YXRlLmV2ZW50Q29kZV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzW3N0YXRlLmV2ZW50Q29kZV0oc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMuYWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5hbGwoc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV0d29ya05hbWUoYmxvY2tjaGFpbiwgaWQpIHtcbiAgcmV0dXJuIG5ldHdvcmtzW2Jsb2NrY2hhaW5dW2lkXTtcbn1cblxuZnVuY3Rpb24gc2VydmVyRWNobyhldmVudENvZGUpIHtcbiAgc3dpdGNoIChldmVudENvZGUpIHtcbiAgICBjYXNlICd0eFJlcXVlc3QnOlxuICAgIGNhc2UgJ25zZkZhaWwnOlxuICAgIGNhc2UgJ3R4UmVwZWF0JzpcbiAgICBjYXNlICd0eEF3YWl0aW5nQXBwcm92YWwnOlxuICAgIGNhc2UgJ3R4Q29uZmlybVJlbWluZGVyJzpcbiAgICBjYXNlICd0eFNlbmRGYWlsJzpcbiAgICBjYXNlICd0eEVycm9yJzpcbiAgICBjYXNlICd0eFVuZGVyUHJpY2VkJzpcbiAgICBjYXNlICd0eFNlbnQnOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxhc3QoYXJyKSB7XG4gIHJldHVybiBhcnIucmV2ZXJzZSgpWzBdO1xufSAvLyBpc0FkZHJlc3MgYW5kIGlzVHhpZCBhcmUgbm90IG1lYW50IHRvIHBlcmZvcm0gcmVhbCB2YWxpZGF0aW9uLFxuLy8ganVzdCBuZWVkcyB0byB3b3JrIG91dCBpZiBpdCBpcyBhbiBhZGRyZXNzIG9yIGEgdHJhbnNhY3Rpb24gaWRcbi8vIHRoZSBzZXJ2ZXIgd2lsbCBkbyBtb3JlIHRob3JvdWdoIHZhbGlkYXRpb25cblxuXG5mdW5jdGlvbiBpc0FkZHJlc3MoYmxvY2tjaGFpbiwgYWRkcmVzc09ySGFzaCkge1xuICBzd2l0Y2ggKGJsb2NrY2hhaW4pIHtcbiAgICBjYXNlICdldGhlcmV1bSc6XG4gICAgICByZXR1cm4gYWRkcmVzc09ySGFzaC5sZW5ndGggPT09IDQyO1xuXG4gICAgY2FzZSAnYml0Y29pbic6XG4gICAgICByZXR1cm4gYWRkcmVzc09ySGFzaC5sZW5ndGggIT09IDY0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1R4aWQoYmxvY2tjaGFpbiwgYWRkcmVzc09ySGFzaCkge1xuICBzd2l0Y2ggKGJsb2NrY2hhaW4pIHtcbiAgICBjYXNlICdldGhlcmV1bSc6XG4gICAgICByZXR1cm4gYWRkcmVzc09ySGFzaC5sZW5ndGggPT09IDY2O1xuXG4gICAgY2FzZSAnYml0Y29pbic6XG4gICAgICByZXR1cm4gYWRkcmVzc09ySGFzaC5sZW5ndGggPT09IDY0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YWl0KHRpbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZSk7XG4gIH0pO1xufVxuXG5jb25zdCBqc29uUHJlc2VydmVVbmRlZmluZWQgPSAoaywgdikgPT4gdiA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiB2O1xuLyoqXHJcbiAqIFRlc3RzIGlmIExvY2FsU3RvcmFnZSBtYXkgYmUgdXNlZC4gQWNjb3VudHMgZm9yIGVudmlyb25tZW50cyB3aGVyZVxyXG4gKiBMb2NhbFN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZCwgYXMgd2VsbCBhcyB0aG9zZSB3aGVyZSBpdCBpcyBibG9ja2VkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgTG9jYWxTdG9yYWdlIGlzIHN1cHBvcnRlZCBhbmQgYWNjZXNzaWJsZSwgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkge1xuICBjb25zdCBpc1N1cHBvcnRlZCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdztcblxuICBpZiAoaXNTdXBwb3J0ZWQpIHtcbiAgICBjb25zdCB0ZXN0S2V5ID0gJ19fdGVzdExvY2FsU3RvcmFnZSc7XG5cbiAgICB0cnkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3RLZXksICcxJyk7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGVzdEtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uKGhhc2gsIGlkKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpOyAvLyBjcmVhdGUgc3RhcnRUaW1lIGZvciB0cmFuc2FjdGlvblxuXG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7IC8vIGNyZWF0ZSBlbWl0dGVyIGZvciB0cmFuc2FjdGlvblxuXG4gIGNvbnN0IGVtaXR0ZXIgPSBjcmVhdGVFbWl0dGVyKCk7IC8vIGNyZWF0ZSBldmVudENvZGUgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZXZlbnRDb2RlID0gJ3R4U2VudCc7IC8vIHB1dCBpbiBxdWV1ZVxuXG4gIHRoaXMud2F0Y2hlZFRyYW5zYWN0aW9ucy5wdXNoKHtcbiAgICBoYXNoLFxuICAgIGVtaXR0ZXJcbiAgfSk7XG4gIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyB7XG4gICAgaGFzaFxuICB9IDoge1xuICAgIHR4aWQ6IGhhc2hcbiAgfTtcbiAgY29uc3QgdHJhbnNhY3Rpb24gPSB7IC4uLnRyYW5zYWN0aW9uSWQsXG4gICAgaWQ6IGlkIHx8IGhhc2gsXG4gICAgc3RhcnRUaW1lLFxuICAgIHN0YXR1czogJ3NlbnQnXG4gIH07XG4gIGNvbnN0IG5ld1N0YXRlID0geyAuLi50cmFuc2FjdGlvbixcbiAgICBldmVudENvZGVcbiAgfTsgLy8gbG9nRXZlbnQgdG8gc2VydmVyXG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGV2ZW50Q29kZSxcbiAgICBjYXRlZ29yeUNvZGU6ICdhY3RpdmVUcmFuc2FjdGlvbicsXG4gICAgdHJhbnNhY3Rpb25cbiAgfSk7XG5cbiAgY29uc3QgdHJhbnNhY3Rpb25PYmogPSB7XG4gICAgZGV0YWlsczogbmV3U3RhdGUsXG4gICAgZW1pdHRlclxuICB9O1xuXG4gIGZ1bmN0aW9uIGVtaXRTdGF0ZSgpIHtcbiAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gZW1pdHRlci5lbWl0KG5ld1N0YXRlKTtcblxuICAgIHRoaXMuX3RyYW5zYWN0aW9uSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoe1xuICAgICAgdHJhbnNhY3Rpb246IG5ld1N0YXRlLFxuICAgICAgZW1pdHRlclJlc3VsdFxuICAgIH0pKTtcbiAgfSAvLyBlbWl0IGFmdGVyIGRlbGF5IHRvIGFsbG93IGZvciBsaXN0ZW5lciB0byBiZSByZWdpc3RlcmVkXG5cblxuICBzZXRUaW1lb3V0KGVtaXRTdGF0ZS5iaW5kKHRoaXMpLCA1KTtcbiAgcmV0dXJuIHRyYW5zYWN0aW9uT2JqO1xufVxuXG5mdW5jdGlvbiBhY2NvdW50KGFkZHJlc3MpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgV2ViU29ja2V0IGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCwgcmUtaW5pdGlhbGl6ZSB0byBjb250aW51ZSBtYWtpbmcgcmVxdWVzdHMuJyk7IC8vIGxvd2VyY2FzZSB0aGUgYWRkcmVzcyBpZiBFdGhlcmV1bVxuXG4gIGFkZHJlc3MgPSB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgOiBhZGRyZXNzOyAvLyBjcmVhdGUgZW1pdHRlciBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBlbWl0dGVyID0gY3JlYXRlRW1pdHRlcigpOyAvLyBjcmVhdGUgZXZlbnRDb2RlIGZvciB0cmFuc2FjdGlvblxuXG4gIGNvbnN0IGV2ZW50Q29kZSA9ICd3YXRjaCc7XG4gIGNvbnN0IGV4aXN0aW5nQWRkcmVzc1dhdGNoZXIgPSB0aGlzLndhdGNoZWRBY2NvdW50cy5maW5kKGFjID0+IGFjLmFkZHJlc3MgPT09IGFkZHJlc3MpO1xuXG4gIGlmIChleGlzdGluZ0FkZHJlc3NXYXRjaGVyKSB7XG4gICAgLy8gYWRkIHRvIGV4aXN0aW5nIGVtaXR0ZXJzIGFycmF5XG4gICAgZXhpc3RpbmdBZGRyZXNzV2F0Y2hlci5lbWl0dGVycy5wdXNoKGVtaXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHB1dCBpbiBhY2NvdW50cyBxdWV1ZVxuICAgIHRoaXMud2F0Y2hlZEFjY291bnRzLnB1c2goe1xuICAgICAgYWRkcmVzcyxcbiAgICAgIGVtaXR0ZXJzOiBbZW1pdHRlcl1cbiAgICB9KTtcbiAgfSAvLyBsb2dFdmVudCB0byBzZXJ2ZXJcblxuXG4gIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICBldmVudENvZGUsXG4gICAgY2F0ZWdvcnlDb2RlOiAnYWNjb3VudEFkZHJlc3MnLFxuICAgIGFjY291bnQ6IHtcbiAgICAgIGFkZHJlc3NcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgZW1pdHRlcixcbiAgICBkZXRhaWxzOiB7XG4gICAgICBhZGRyZXNzXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBldmVudChldmVudE9iaikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTtcblxuICB0aGlzLl9zZW5kTWVzc2FnZShldmVudE9iaik7XG59XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzID0gZmFsc2U7XG52YXIgY29uZmlnID0ge1xuICBQcm9taXNlOiB1bmRlZmluZWQsXG5cbiAgc2V0IHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhciBlcnJvciA9IC8qQF9fUFVSRV9fKi9uZXcgRXJyb3IoKTtcbiAgICAgIC8qQF9fUFVSRV9fKi9cblxuICAgICAgY29uc29sZS53YXJuKCdERVBSRUNBVEVEISBSeEpTIHdhcyBzZXQgdG8gdXNlIGRlcHJlY2F0ZWQgc3luY2hyb25vdXMgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IgYnkgY29kZSBhdDogXFxuJyArIGVycm9yLnN0YWNrKTtcbiAgICB9XG5cbiAgICBfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3MgPSB2YWx1ZTtcbiAgfSxcblxuICBnZXQgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZygpIHtcbiAgICByZXR1cm4gX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzO1xuICB9XG5cbn07XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cbmZ1bmN0aW9uIGhvc3RSZXBvcnRFcnJvcihlcnIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9LCAwKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX2NvbmZpZyxfdXRpbF9ob3N0UmVwb3J0RXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBlbXB0eSA9IHtcbiAgY2xvc2VkOiB0cnVlLFxuICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHt9LFxuICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICB9XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fVxufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxudmFyIGlzQXJyYXkgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7XG4gIH07XG59KCk7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvckltcGwoZXJyb3JzKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvcnMgPyBlcnJvcnMubGVuZ3RoICsgXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXG5cIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkge1xuICAgICAgcmV0dXJuIGkgKyAxICsgXCIpIFwiICsgZXJyLnRvU3RyaW5nKCk7XG4gICAgfSkuam9pbignXFxuICAnKSA6ICcnO1xuICAgIHRoaXMubmFtZSA9ICdVbnN1YnNjcmlwdGlvbkVycm9yJztcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsLnByb3RvdHlwZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIHJldHVybiBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbDtcbn0oKTtcblxudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbDtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3V0aWxfaXNBcnJheSxfdXRpbF9pc09iamVjdCxfdXRpbF9pc0Z1bmN0aW9uLF91dGlsX1Vuc3Vic2NyaXB0aW9uRXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG52YXIgU3Vic2NyaXB0aW9uID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBudWxsO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuXG4gICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLl9jdG9yVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICB9XG4gIH1cblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnJvcnM7XG5cbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSB0aGlzLFxuICAgICAgICBfcGFyZW50T3JQYXJlbnRzID0gX2EuX3BhcmVudE9yUGFyZW50cyxcbiAgICAgICAgX2N0b3JVbnN1YnNjcmliZSA9IF9hLl9jdG9yVW5zdWJzY3JpYmUsXG4gICAgICAgIF91bnN1YnNjcmliZSA9IF9hLl91bnN1YnNjcmliZSxcbiAgICAgICAgX3N1YnNjcmlwdGlvbnMgPSBfYS5fc3Vic2NyaXB0aW9ucztcblxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBudWxsO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuXG4gICAgaWYgKF9wYXJlbnRPclBhcmVudHMgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgIF9wYXJlbnRPclBhcmVudHMucmVtb3ZlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoX3BhcmVudE9yUGFyZW50cyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IF9wYXJlbnRPclBhcmVudHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBwYXJlbnRfMSA9IF9wYXJlbnRPclBhcmVudHNbaW5kZXhdO1xuICAgICAgICBwYXJlbnRfMS5yZW1vdmUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgaWYgKF9jdG9yVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIF91bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcnMgPSBlIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvciA/IGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlLmVycm9ycykgOiBbZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW4gPSBfc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgIHZhciBzdWIgPSBfc3Vic2NyaXB0aW9uc1tpbmRleF07XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZS5lcnJvcnMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgfVxuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRlYXJkb3duO1xuXG4gICAgaWYgKCF0ZWFyZG93bikge1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRlYXJkb3duKTtcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PT0gdGhpcyB8fCBzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICghKHN1YnNjcmlwdGlvbiBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24uX3N1YnNjcmlwdGlvbnMgPSBbdG1wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX3BhcmVudE9yUGFyZW50cyA9IHN1YnNjcmlwdGlvbi5fcGFyZW50T3JQYXJlbnRzO1xuXG4gICAgaWYgKF9wYXJlbnRPclBhcmVudHMgPT09IG51bGwpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5fcGFyZW50T3JQYXJlbnRzID0gdGhpcztcbiAgICB9IGVsc2UgaWYgKF9wYXJlbnRPclBhcmVudHMgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgIGlmIChfcGFyZW50T3JQYXJlbnRzID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICB9XG5cbiAgICAgIHN1YnNjcmlwdGlvbi5fcGFyZW50T3JQYXJlbnRzID0gW19wYXJlbnRPclBhcmVudHMsIHRoaXNdO1xuICAgIH0gZWxzZSBpZiAoX3BhcmVudE9yUGFyZW50cy5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICAgICAgX3BhcmVudE9yUGFyZW50cy5wdXNoKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH1cblxuICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcblxuICAgIGlmIChzdWJzY3JpcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW3N1YnNjcmlwdGlvbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuXG4gICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb25JbmRleCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWJzY3JpcHRpb24pO1xuXG4gICAgICBpZiAoc3Vic2NyaXB0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbkluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLkVNUFRZID0gZnVuY3Rpb24gKGVtcHR5KSB7XG4gICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH0obmV3IFN1YnNjcmlwdGlvbigpKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG5mdW5jdGlvbiBmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyb3JzKSB7XG4gIHJldHVybiBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChlcnJzLCBlcnIpIHtcbiAgICByZXR1cm4gZXJycy5jb25jYXQoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvciA/IGVyci5lcnJvcnMgOiBlcnIpO1xuICB9LCBbXSk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIHJ4U3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID8gLypAX19QVVJFX18qL1N5bWJvbCgncnhTdWJzY3JpYmVyJykgOiAnQEByeFN1YnNjcmliZXJfJyArIC8qQF9fUFVSRV9fKi9NYXRoLnJhbmRvbSgpO1xufSgpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfdXRpbF9pc0Z1bmN0aW9uLF9PYnNlcnZlcixfU3Vic2NyaXB0aW9uLF9pbnRlcm5hbF9zeW1ib2xfcnhTdWJzY3JpYmVyLF9jb25maWcsX3V0aWxfaG9zdFJlcG9ydEVycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YnNjcmliZXIoZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zeW5jRXJyb3JWYWx1ZSA9IG51bGw7XG4gICAgX3RoaXMuc3luY0Vycm9yVGhyb3duID0gZmFsc2U7XG4gICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG5cbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBlbXB0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZW1wdHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uT3JOZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGRlc3RpbmF0aW9uT3JOZXh0LnN5bmNFcnJvclRocm93YWJsZTtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb25Pck5leHQ7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbk9yTmV4dC5hZGQoX3RoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIoX3RoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcihfdGhpcywgZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU3Vic2NyaWJlci5jcmVhdGUgPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgfVxuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuXG4gICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcGFyZW50T3JQYXJlbnRzID0gdGhpcy5fcGFyZW50T3JQYXJlbnRzO1xuICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IG51bGw7XG4gICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBfcGFyZW50T3JQYXJlbnRzO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb24pO1xuXG52YXIgU2FmZVN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudFN1YnNjcmliZXIsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBfcGFyZW50U3Vic2NyaWJlcjtcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgY29udGV4dCA9IF90aGlzO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpKSB7XG4gICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgfSBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcblxuICAgICAgaWYgKG9ic2VydmVyT3JOZXh0ICE9PSBlbXB0eSkge1xuICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dC51bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICBfdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSBfdGhpcy51bnN1YnNjcmliZS5iaW5kKF90aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgX3RoaXMuX25leHQgPSBuZXh0O1xuICAgIF90aGlzLl9lcnJvciA9IGVycm9yO1xuICAgIF90aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCAmJiB0aGlzLl9uZXh0KSB7XG4gICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuXG4gICAgICBpZiAoIWNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nIHx8ICFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fbmV4dCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fbmV4dCwgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICB2YXIgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyA9IGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nO1xuXG4gICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgaWYgKCF1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nIHx8ICFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9lcnJvciwgZXJyKTtcblxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fZXJyb3IsIGVycik7XG5cbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG5cbiAgICAgICAgaWYgKHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuXG4gICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHdyYXBwZWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbXBsZXRlLmNhbGwoX3RoaXMuX2NvbnRleHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHdyYXBwZWRDb21wbGV0ZSk7XG5cbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHdyYXBwZWRDb21wbGV0ZSk7XG5cbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JVbnN1YiA9IGZ1bmN0aW9uIChmbiwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JTZXRFcnJvciA9IGZ1bmN0aW9uIChwYXJlbnQsIGZuLCB2YWx1ZSkge1xuICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNhbGwnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICBwYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gbnVsbDtcblxuICAgIF9wYXJlbnRTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XG4gIH07XG5cbiAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX1N1YnNjcmliZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGNhblJlcG9ydEVycm9yKG9ic2VydmVyKSB7XG4gIHdoaWxlIChvYnNlcnZlcikge1xuICAgIHZhciBfYSA9IG9ic2VydmVyLFxuICAgICAgICBjbG9zZWRfMSA9IF9hLmNsb3NlZCxcbiAgICAgICAgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbixcbiAgICAgICAgaXNTdG9wcGVkID0gX2EuaXNTdG9wcGVkO1xuXG4gICAgaWYgKGNsb3NlZF8xIHx8IGlzU3RvcHBlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24gaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICBvYnNlcnZlciA9IGRlc3RpbmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9TdWJzY3JpYmVyLF9zeW1ib2xfcnhTdWJzY3JpYmVyLF9PYnNlcnZlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgaWYgKG5leHRPck9ic2VydmVyKSB7XG4gICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgIH1cblxuICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJdKSB7XG4gICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbmV4dE9yT2JzZXJ2ZXIgJiYgIWVycm9yICYmICFjb21wbGV0ZSkge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcihlbXB0eSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFN1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIG9ic2VydmFibGUgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCAnQEBvYnNlcnZhYmxlJztcbn0oKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfaWRlbnRpdHkgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIHBpcGVGcm9tQXJyYXkoZm5zKSB7XG4gIGlmIChmbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG5cbiAgaWYgKGZucy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZm5zWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGZucy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGZuKSB7XG4gICAgICByZXR1cm4gZm4ocHJldik7XG4gICAgfSwgaW5wdXQpO1xuICB9O1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfdXRpbF9jYW5SZXBvcnRFcnJvcixfdXRpbF90b1N1YnNjcmliZXIsX3N5bWJvbF9vYnNlcnZhYmxlLF91dGlsX3BpcGUsX2NvbmZpZyBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIE9ic2VydmFibGUgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG5cbiAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgfVxuICB9XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcblxuICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgc2luay5hZGQob3BlcmF0b3IuY2FsbChzaW5rLCB0aGlzLnNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaW5rLmFkZCh0aGlzLnNvdXJjZSB8fCBjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyAmJiAhc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPyB0aGlzLl9zdWJzY3JpYmUoc2luaykgOiB0aGlzLl90cnlTdWJzY3JpYmUoc2luaykpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaW5rO1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHNpbmspO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgc2luay5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhblJlcG9ydEVycm9yKHNpbmspKSB7XG4gICAgICAgIHNpbmsuZXJyb3IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIHByb21pc2VDdG9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xuICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHJldHVybiBzb3VyY2UgJiYgc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcGVyYXRpb25zID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgb3BlcmF0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBpcGVGcm9tQXJyYXkob3BlcmF0aW9ucykodGhpcyk7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2VDdG9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xuICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID0geDtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oKTtcblxuZnVuY3Rpb24gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpIHtcbiAgaWYgKCFwcm9taXNlQ3Rvcikge1xuICAgIHByb21pc2VDdG9yID0gUHJvbWlzZTtcbiAgfVxuXG4gIGlmICghcHJvbWlzZUN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2VDdG9yO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBzdWJzY3JpYmVUb0FycmF5ID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW4gJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpXSk7XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICB9O1xufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX2hvc3RSZXBvcnRFcnJvciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIHN1YnNjcmliZVRvUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgfSkudGhlbihudWxsLCBob3N0UmVwb3J0RXJyb3IpO1xuICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICB9O1xufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBnZXRTeW1ib2xJdGVyYXRvcigpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicgfHwgIVN5bWJvbC5pdGVyYXRvcikge1xuICAgIHJldHVybiAnQEBpdGVyYXRvcic7XG4gIH1cblxuICByZXR1cm4gU3ltYm9sLml0ZXJhdG9yO1xufVxuXG52YXIgaXRlcmF0b3IgPSAvKkBfX1BVUkVfXyovZ2V0U3ltYm9sSXRlcmF0b3IoKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3N5bWJvbF9pdGVyYXRvciBQVVJFX0lNUE9SVFNfRU5EICovXG5cbnZhciBzdWJzY3JpYmVUb0l0ZXJhYmxlID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHZhciBpdGVyYXRvciQxID0gaXRlcmFibGVbaXRlcmF0b3JdKCk7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgaXRlbSA9IHZvaWQgMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaXRlbSA9IGl0ZXJhdG9yJDEubmV4dCgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtLmRvbmUpIHtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3Vic2NyaWJlci5uZXh0KGl0ZW0udmFsdWUpO1xuXG4gICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yJDEucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdWJzY3JpYmVyLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpdGVyYXRvciQxLnJldHVybikge1xuICAgICAgICAgIGl0ZXJhdG9yJDEucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICB9O1xufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3N5bWJvbF9vYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgc3Vic2NyaWJlVG9PYnNlcnZhYmxlID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB2YXIgb2JzID0gb2JqW29ic2VydmFibGVdKCk7XG5cbiAgICBpZiAodHlwZW9mIG9icy5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIG9iamVjdCBkb2VzIG5vdCBjb3JyZWN0bHkgaW1wbGVtZW50IFN5bWJvbC5vYnNlcnZhYmxlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYnMuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH1cbiAgfTtcbn07XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeCAhPT0gJ2Z1bmN0aW9uJztcbn07XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9zdWJzY3JpYmVUb0FycmF5LF9zdWJzY3JpYmVUb1Byb21pc2UsX3N1YnNjcmliZVRvSXRlcmFibGUsX3N1YnNjcmliZVRvT2JzZXJ2YWJsZSxfaXNBcnJheUxpa2UsX2lzUHJvbWlzZSxfaXNPYmplY3QsX3N5bWJvbF9pdGVyYXRvcixfc3ltYm9sX29ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBzdWJzY3JpYmVUbyA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgaWYgKCEhcmVzdWx0ICYmIHR5cGVvZiByZXN1bHRbb2JzZXJ2YWJsZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlVG9PYnNlcnZhYmxlKHJlc3VsdCk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheUxpa2UocmVzdWx0KSkge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb0FycmF5KHJlc3VsdCk7XG4gIH0gZWxzZSBpZiAoaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlVG9Qcm9taXNlKHJlc3VsdCk7XG4gIH0gZWxzZSBpZiAoISFyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtpdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3Vic2NyaWJlVG9JdGVyYWJsZShyZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciB2YWx1ZSA9IGlzT2JqZWN0KHJlc3VsdCkgPyAnYW4gaW52YWxpZCBvYmplY3QnIDogXCInXCIgKyByZXN1bHQgKyBcIidcIjtcbiAgICB2YXIgbXNnID0gXCJZb3UgcHJvdmlkZWQgXCIgKyB2YWx1ZSArIFwiIHdoZXJlIGEgc3RyZWFtIHdhcyBleHBlY3RlZC5cIiArICcgWW91IGNhbiBwcm92aWRlIGFuIE9ic2VydmFibGUsIFByb21pc2UsIEFycmF5LCBvciBJdGVyYWJsZS4nO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKTtcbiAgfVxufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YnNjcmliZXIsX09ic2VydmFibGUsX3V0aWxfc3Vic2NyaWJlVG8gUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBTaW1wbGVJbm5lclN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2ltcGxlSW5uZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNpbXBsZUlubmVyU3Vic2NyaWJlcihwYXJlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFNpbXBsZUlubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnBhcmVudC5ub3RpZnlOZXh0KHZhbHVlKTtcbiAgfTtcblxuICBTaW1wbGVJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHRoaXMucGFyZW50Lm5vdGlmeUVycm9yKGVycm9yKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gIH07XG5cbiAgU2ltcGxlSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXJlbnQubm90aWZ5Q29tcGxldGUoKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gIH07XG5cbiAgcmV0dXJuIFNpbXBsZUlubmVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcik7XG5cbnZhciBTaW1wbGVPdXRlclN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2ltcGxlT3V0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFNpbXBsZU91dGVyU3Vic2NyaWJlcigpIHtcbiAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICBTaW1wbGVPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAoaW5uZXJWYWx1ZSkge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgfTtcblxuICBTaW1wbGVPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgfTtcblxuICBTaW1wbGVPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlT3V0ZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKTtcblxuZnVuY3Rpb24gaW5uZXJTdWJzY3JpYmUocmVzdWx0LCBpbm5lclN1YnNjcmliZXIpIHtcbiAgaWYgKGlubmVyU3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShpbm5lclN1YnNjcmliZXIpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNjcmliZVRvKHJlc3VsdCkoaW5uZXJTdWJzY3JpYmVyKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YnNjcmlwdGlvbiBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIEFjdGlvbiA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBY3Rpb24sIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICB9XG5cbiAgQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQWN0aW9uO1xufShTdWJzY3JpcHRpb24pO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfQWN0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgQXN5bmNBY3Rpb24gPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQXN5bmNBY3Rpb24sIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQXN5bmNBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIF90aGlzLndvcmsgPSB3b3JrO1xuICAgIF90aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgdGhpcy5pZCA9IHRoaXMuaWQgfHwgdGhpcy5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIHRoaXMuaWQsIGRlbGF5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBzZXRJbnRlcnZhbChzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIHRoaXMpLCBkZWxheSk7XG4gIH07XG5cbiAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgdGhpcy5kZWxheSA9PT0gZGVsYXkgJiYgdGhpcy5wZW5kaW5nID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIGNsZWFySW50ZXJ2YWwoaWQpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdleGVjdXRpbmcgYSBjYW5jZWxsZWQgYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG5cbiAgICB2YXIgZXJyb3IgPSB0aGlzLl9leGVjdXRlKHN0YXRlLCBkZWxheSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGVuZGluZyA9PT0gZmFsc2UgJiYgdGhpcy5pZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZCh0aGlzLnNjaGVkdWxlciwgdGhpcy5pZCwgbnVsbCk7XG4gICAgfVxuICB9O1xuXG4gIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICB2YXIgZXJyb3JlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvclZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud29yayhzdGF0ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICBlcnJvclZhbHVlID0gISFlICYmIGUgfHwgbmV3IEVycm9yKGUpO1xuICAgIH1cblxuICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgIHZhciBpbmRleCA9IGFjdGlvbnMuaW5kZXhPZih0aGlzKTtcbiAgICB0aGlzLndvcmsgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGFjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgbnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWxheSA9IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIEFzeW5jQWN0aW9uO1xufShBY3Rpb24pO1xuXG52YXIgU2NoZWR1bGVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7XG4gICAgICBub3cgPSBTY2hlZHVsZXIubm93O1xuICAgIH1cblxuICAgIHRoaXMuU2NoZWR1bGVyQWN0aW9uID0gU2NoZWR1bGVyQWN0aW9uO1xuICAgIHRoaXMubm93ID0gbm93O1xuICB9XG5cbiAgU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uICh3b3JrLCBkZWxheSwgc3RhdGUpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgdGhpcy5TY2hlZHVsZXJBY3Rpb24odGhpcywgd29yaykuc2NoZWR1bGUoc3RhdGUsIGRlbGF5KTtcbiAgfTtcblxuICBTY2hlZHVsZXIubm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xuXG4gIHJldHVybiBTY2hlZHVsZXI7XG59KCk7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TY2hlZHVsZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBBc3luY1NjaGVkdWxlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBc3luY1NjaGVkdWxlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBc3luY1NjaGVkdWxlcihTY2hlZHVsZXJBY3Rpb24sIG5vdykge1xuICAgIGlmIChub3cgPT09IHZvaWQgMCkge1xuICAgICAgbm93ID0gU2NoZWR1bGVyLm5vdztcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBTY2hlZHVsZXJBY3Rpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChBc3luY1NjaGVkdWxlci5kZWxlZ2F0ZSAmJiBBc3luY1NjaGVkdWxlci5kZWxlZ2F0ZSAhPT0gX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlLm5vdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vdygpO1xuICAgICAgfVxuICAgIH0pIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5hY3Rpb25zID0gW107XG4gICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgX3RoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEFzeW5jU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uICh3b3JrLCBkZWxheSwgc3RhdGUpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIGlmIChBc3luY1NjaGVkdWxlci5kZWxlZ2F0ZSAmJiBBc3luY1NjaGVkdWxlci5kZWxlZ2F0ZSAhPT0gdGhpcykge1xuICAgICAgcmV0dXJuIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlLnNjaGVkdWxlKHdvcmssIGRlbGF5LCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnNjaGVkdWxlLmNhbGwodGhpcywgd29yaywgZGVsYXksIHN0YXRlKTtcbiAgICB9XG4gIH07XG5cbiAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuXG4gICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3I7XG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSk7XG5cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSB7XG4gICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFzeW5jU2NoZWR1bGVyO1xufShTY2hlZHVsZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfQXN5bmNBY3Rpb24sX0FzeW5jU2NoZWR1bGVyIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgYXN5bmNTY2hlZHVsZXIgPSAvKkBfX1BVUkVfXyovbmV3IEFzeW5jU2NoZWR1bGVyKEFzeW5jQWN0aW9uKTtcbnZhciBhc3luYyA9IGFzeW5jU2NoZWR1bGVyO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oK3ZhbHVlKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX09ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBFTVBUWSA9IC8qQF9fUFVSRV9fKi9uZXcgT2JzZXJ2YWJsZShmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xufSk7XG5cbmZ1bmN0aW9uIGVtcHR5JDEoc2NoZWR1bGVyKSB7XG4gIHJldHVybiBzY2hlZHVsZXIgPyBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIDogRU1QVFk7XG59XG5cbmZ1bmN0aW9uIGVtcHR5U2NoZWR1bGVkKHNjaGVkdWxlcikge1xuICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfT2JzZXJ2YWJsZSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihlcnJvciwgc2NoZWR1bGVyKSB7XG4gIGlmICghc2NoZWR1bGVyKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlci5lcnJvcihlcnJvcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoLCAwLCB7XG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2goX2EpIHtcbiAgdmFyIGVycm9yID0gX2EuZXJyb3IsXG4gICAgICBzdWJzY3JpYmVyID0gX2Euc3Vic2NyaWJlcjtcbiAgc3Vic2NyaWJlci5lcnJvcihlcnJvcik7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbCA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbCgpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZSA9ICdhcmd1bWVudCBvdXQgb2YgcmFuZ2UnO1xuICAgIHRoaXMubmFtZSA9ICdBcmd1bWVudE91dE9mUmFuZ2VFcnJvcic7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGwucHJvdG90eXBlID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgcmV0dXJuIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbDtcbn0oKTtcblxudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZpbHRlck9wZXJhdG9yRnVuY3Rpb24oc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpKTtcbiAgfTtcbn1cblxudmFyIEZpbHRlck9wZXJhdG9yID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgfVxuXG4gIEZpbHRlck9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaWx0ZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcpKTtcbiAgfTtcblxuICByZXR1cm4gRmlsdGVyT3BlcmF0b3I7XG59KCk7XG5cbnZhciBGaWx0ZXJTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEZpbHRlclN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRmlsdGVyU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgX3RoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgX3RoaXMuY291bnQgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEZpbHRlclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZS5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEZpbHRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfdXRpbF9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcixfb2JzZXJ2YWJsZV9lbXB0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdGFrZShjb3VudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5JDEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUYWtlT3BlcmF0b3IoY291bnQpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBUYWtlT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUYWtlT3BlcmF0b3IodG90YWwpIHtcbiAgICB0aGlzLnRvdGFsID0gdG90YWw7XG5cbiAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIFRha2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICB9O1xuXG4gIHJldHVybiBUYWtlT3BlcmF0b3I7XG59KCk7XG5cbnZhciBUYWtlU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUYWtlU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBUYWtlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdG90YWwpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLnRvdGFsID0gdG90YWw7XG4gICAgX3RoaXMuY291bnQgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRha2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgdmFyIGNvdW50ID0gKyt0aGlzLmNvdW50O1xuXG4gICAgaWYgKGNvdW50IDw9IHRvdGFsKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuXG4gICAgICBpZiAoY291bnQgPT09IHRvdGFsKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGFrZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfU3Vic2NyaXB0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBmaW5hbGl6ZShjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UubGlmdChuZXcgRmluYWxseU9wZXJhdG9yKGNhbGxiYWNrKSk7XG4gIH07XG59XG5cbnZhciBGaW5hbGx5T3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBGaW5hbGx5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbmFsbHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2FsbGJhY2spKTtcbiAgfTtcblxuICByZXR1cm4gRmluYWxseU9wZXJhdG9yO1xufSgpO1xuXG52YXIgRmluYWxseVN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoRmluYWxseVN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gRmluYWxseVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5hZGQobmV3IFN1YnNjcmlwdGlvbihjYWxsYmFjaykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEZpbmFsbHlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1N1YnNjcmliZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIHRha2VXaGlsZShwcmVkaWNhdGUsIGluY2x1c2l2ZSkge1xuICBpZiAoaW5jbHVzaXZlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdXNpdmUgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUYWtlV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUsIGluY2x1c2l2ZSkpO1xuICB9O1xufVxuXG52YXIgVGFrZVdoaWxlT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUYWtlV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUsIGluY2x1c2l2ZSkge1xuICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIHRoaXMuaW5jbHVzaXZlID0gaW5jbHVzaXZlO1xuICB9XG5cbiAgVGFrZVdoaWxlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VXaGlsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMuaW5jbHVzaXZlKSk7XG4gIH07XG5cbiAgcmV0dXJuIFRha2VXaGlsZU9wZXJhdG9yO1xufSgpO1xuXG52YXIgVGFrZVdoaWxlU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUYWtlV2hpbGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFRha2VXaGlsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgaW5jbHVzaXZlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgX3RoaXMuaW5jbHVzaXZlID0gaW5jbHVzaXZlO1xuICAgIF90aGlzLmluZGV4ID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUYWtlV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgdGhpcy5pbmRleCsrKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5uZXh0T3JDb21wbGV0ZSh2YWx1ZSwgcmVzdWx0KTtcbiAgfTtcblxuICBUYWtlV2hpbGVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0T3JDb21wbGV0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJlZGljYXRlUmVzdWx0KSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcblxuICAgIGlmIChCb29sZWFuKHByZWRpY2F0ZVJlc3VsdCkpIHtcbiAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5pbmNsdXNpdmUpIHtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUYWtlV2hpbGVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgVGltZW91dEVycm9ySW1wbCA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRpbWVvdXRFcnJvckltcGwoKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVGltZW91dCBoYXMgb2NjdXJyZWQnO1xuICAgIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgVGltZW91dEVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICByZXR1cm4gVGltZW91dEVycm9ySW1wbDtcbn0oKTtcblxudmFyIFRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvckltcGw7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9zY2hlZHVsZXJfYXN5bmMsX3V0aWxfaXNEYXRlLF9pbm5lclN1YnNjcmliZSBQVVJFX0lNUE9SVFNfRU5EICovXG5cbmZ1bmN0aW9uIHRpbWVvdXRXaXRoKGR1ZSwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHtcbiAgICBzY2hlZHVsZXIgPSBhc3luYztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgdmFyIGFic29sdXRlVGltZW91dCA9IGlzRGF0ZShkdWUpO1xuICAgIHZhciB3YWl0Rm9yID0gYWJzb2x1dGVUaW1lb3V0ID8gK2R1ZSAtIHNjaGVkdWxlci5ub3coKSA6IE1hdGguYWJzKGR1ZSk7XG4gICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUaW1lb3V0V2l0aE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikpO1xuICB9O1xufVxuXG52YXIgVGltZW91dFdpdGhPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRpbWVvdXRXaXRoT3BlcmF0b3Iod2FpdEZvciwgYWJzb2x1dGVUaW1lb3V0LCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSB7XG4gICAgdGhpcy53YWl0Rm9yID0gd2FpdEZvcjtcbiAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICB0aGlzLndpdGhPYnNlcnZhYmxlID0gd2l0aE9ic2VydmFibGU7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gIH1cblxuICBUaW1lb3V0V2l0aE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lb3V0V2l0aFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hYnNvbHV0ZVRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcy53aXRoT2JzZXJ2YWJsZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgfTtcblxuICByZXR1cm4gVGltZW91dFdpdGhPcGVyYXRvcjtcbn0oKTtcblxudmFyIFRpbWVvdXRXaXRoU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUaW1lb3V0V2l0aFN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVGltZW91dFdpdGhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhYnNvbHV0ZVRpbWVvdXQsIHdhaXRGb3IsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICBfdGhpcy53YWl0Rm9yID0gd2FpdEZvcjtcbiAgICBfdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgIF90aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcblxuICAgIF90aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGltZW91dFdpdGhTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIHdpdGhPYnNlcnZhYmxlID0gc3Vic2NyaWJlci53aXRoT2JzZXJ2YWJsZTtcblxuICAgIHN1YnNjcmliZXIuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuXG4gICAgc3Vic2NyaWJlci5hZGQoaW5uZXJTdWJzY3JpYmUod2l0aE9ic2VydmFibGUsIG5ldyBTaW1wbGVJbm5lclN1YnNjcmliZXIoc3Vic2NyaWJlcikpKTtcbiAgfTtcblxuICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG5cbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbi5zY2hlZHVsZSh0aGlzLCB0aGlzLndhaXRGb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZCh0aGlzLmFjdGlvbiA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKFRpbWVvdXRXaXRoU3Vic2NyaWJlci5kaXNwYXRjaFRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcykpO1xuICAgIH1cbiAgfTtcblxuICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmFic29sdXRlVGltZW91dCkge1xuICAgICAgdGhpcy5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICB9XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLl9uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICB9O1xuXG4gIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICB0aGlzLndpdGhPYnNlcnZhYmxlID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gVGltZW91dFdpdGhTdWJzY3JpYmVyO1xufShTaW1wbGVPdXRlclN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc2NoZWR1bGVyX2FzeW5jLF91dGlsX1RpbWVvdXRFcnJvcixfdGltZW91dFdpdGgsX29ic2VydmFibGVfdGhyb3dFcnJvciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdGltZW91dChkdWUsIHNjaGVkdWxlcikge1xuICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHtcbiAgICBzY2hlZHVsZXIgPSBhc3luYztcbiAgfVxuXG4gIHJldHVybiB0aW1lb3V0V2l0aChkdWUsIHRocm93RXJyb3IobmV3IFRpbWVvdXRFcnJvcigpKSwgc2NoZWR1bGVyKTtcbn1cblxuY29uc3Qgc2ltdWxhdGlvbnMkID0gbmV3IFN1YmplY3QoKTtcblxuZnVuY3Rpb24gc2ltdWxhdGUoc3lzdGVtLCBuZXR3b3JrLCB0cmFuc2FjdGlvbikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTtcbiAgY29uc3QgaWQgPSBuYW5vaWQoKTsgLy8gc2VuZCBwYXlsb2FkIHRvIHNlcnZlclxuXG4gIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICBjYXRlZ29yeUNvZGU6ICdzaW11bGF0ZScsXG4gICAgZXZlbnRDb2RlOiAndHhTaW11bGF0aW9uJyxcbiAgICBldmVudElkOiBpZCxcbiAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzaW11bGF0aW9ucyQucGlwZShmaWx0ZXIoKHtcbiAgICAgIGV2ZW50SWRcbiAgICB9KSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRJZCA9PT0gaWQ7XG4gICAgfSksIHRha2UoMSkpLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe1xuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgfSkgPT4gcmVzb2x2ZSh0cmFuc2FjdGlvbiksXG4gICAgICBlcnJvcjogKHtcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pID0+IHJlamVjdChlcnJvci5tZXNzYWdlKVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbXVsdGlTaW0odHJhbnNhY3Rpb25zKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuICBjb25zdCBpZCA9IG5hbm9pZCgpOyAvLyBzZW5kIHBheWxvYWQgdG8gc2VydmVyXG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGNhdGVnb3J5Q29kZTogJ3NpbXVsYXRlJyxcbiAgICBldmVudENvZGU6ICd0eFNpbXVsYXRpb24nLFxuICAgIGV2ZW50SWQ6IGlkLFxuICAgIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbnNcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzaW11bGF0aW9ucyQucGlwZShmaWx0ZXIoKHtcbiAgICAgIGV2ZW50SWRcbiAgICB9KSA9PiB7XG4gICAgICByZXR1cm4gZXZlbnRJZCA9PT0gaWQ7XG4gICAgfSksIHRha2UoMSkpLnN1YnNjcmliZSh7XG4gICAgICBuZXh0OiAoe1xuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgfSkgPT4gcmVzb2x2ZSh0cmFuc2FjdGlvbiksXG4gICAgICBlcnJvcjogKHtcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pID0+IHJlamVjdChlcnJvci5tZXNzYWdlKVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5zdWJzY3JpYmUoYWRkcmVzc09ySGFzaCkge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTtcbiAgY29uc3QgYWRkcmVzcyA9IGlzQWRkcmVzcyh0aGlzLl9zeXN0ZW0sIGFkZHJlc3NPckhhc2gpO1xuICBjb25zdCB0eGlkID0gaXNUeGlkKHRoaXMuX3N5c3RlbSwgYWRkcmVzc09ySGFzaCk7IC8vIGNoZWNrIGlmIGl0IGlzIGFuIGFkZHJlc3Mgb3IgYSBoYXNoXG5cbiAgaWYgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBub3JtYWxpemVkQWRkcmVzcyA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IGFkZHJlc3NPckhhc2gudG9Mb3dlckNhc2UoKSA6IGFkZHJlc3NPckhhc2g7IC8vIHJlbW92ZSBhZGRyZXNzIGZyb20gYWNjb3VudHNcblxuICAgIHRoaXMud2F0Y2hlZEFjY291bnRzID0gdGhpcy53YXRjaGVkQWNjb3VudHMuZmlsdGVyKGFjID0+IGFjLmFkZHJlc3MgIT09IG5vcm1hbGl6ZWRBZGRyZXNzKTsgLy8gcmVtb3ZlIGNvbmZpZ3VyYXRpb24gZnJvbSBtZW1vcnlcblxuICAgIHRoaXMuY29uZmlndXJhdGlvbnMuZGVsZXRlKG5vcm1hbGl6ZWRBZGRyZXNzKTsgLy8gbG9nRXZlbnQgdG8gc2VydmVyXG5cbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBjYXRlZ29yeUNvZGU6ICdhY2NvdW50QWRkcmVzcycsXG4gICAgICBldmVudENvZGU6ICd1bndhdGNoJyxcbiAgICAgIGFjY291bnQ6IHtcbiAgICAgICAgYWRkcmVzczogbm9ybWFsaXplZEFkZHJlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eGlkKSB7XG4gICAgLy8gcmVtb3ZlIHRyYW5zYWN0aW9uIGZyb20gdHJhbnNhY3Rpb25zXG4gICAgdGhpcy53YXRjaGVkVHJhbnNhY3Rpb25zID0gdGhpcy53YXRjaGVkVHJhbnNhY3Rpb25zLmZpbHRlcih0eCA9PiB0eC5oYXNoICE9PSBhZGRyZXNzT3JIYXNoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8ge1xuICAgICAgaGFzaDogYWRkcmVzc09ySGFzaFxuICAgIH0gOiB7XG4gICAgICB0eGlkOiBhZGRyZXNzT3JIYXNoXG4gICAgfTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHsgLi4udHJhbnNhY3Rpb25JZCxcbiAgICAgIGlkOiBhZGRyZXNzT3JIYXNoLFxuICAgICAgc3RhdHVzOiAndW5zdWJzY3JpYmVkJ1xuICAgIH07IC8vIGxvZ0V2ZW50IHRvIHNlcnZlclxuXG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgY2F0ZWdvcnlDb2RlOiAnYWN0aXZlVHJhbnNhY3Rpb24nLFxuICAgICAgZXZlbnRDb2RlOiAndW53YXRjaCcsXG4gICAgICB0cmFuc2FjdGlvblxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgdHJ5aW5nIHRvIHVuc3Vic2NyaWJlICR7YWRkcmVzc09ySGFzaH06IG5vdCBhIHZhbGlkIGFkZHJlc3Mgb3IgdHJhbnNhY3Rpb24gaWQvaGFzaGApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyYXRpb24oY29uZmlnKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBXZWJTb2NrZXQgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkLCByZS1pbml0aWFsaXplIHRvIGNvbnRpbnVlIG1ha2luZyByZXF1ZXN0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IGNhc2VkU2NvcGUgPSB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyBjb25maWcuc2NvcGUudG9Mb3dlckNhc2UoKSA6IGNvbmZpZy5zY29wZTsgLy8gcmVzb2x2ZSBwcmV2aW91cyBjb25maWd1cmF0aW9uIGlmIGV4aXN0c1xuXG4gIGNvbnN0IHByZXZpb3VzQ29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZ2V0KGNhc2VkU2NvcGUpO1xuICBwcmV2aW91c0NvbmZpZ3VyYXRpb24gJiYgcHJldmlvdXNDb25maWd1cmF0aW9uLnN1YnNjcmlwdGlvbiAmJiBwcmV2aW91c0NvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uLm5leHQoKTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YmplY3QoKTsgLy8gY3JlYXRlIGVtaXR0ZXIgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZW1pdHRlciA9IGNvbmZpZy53YXRjaEFkZHJlc3MgPyB7XG4gICAgZW1pdHRlcjogY3JlYXRlRW1pdHRlcigpXG4gIH0gOiB7fTtcbiAgdGhpcy5jb25maWd1cmF0aW9ucy5zZXQoY2FzZWRTY29wZSwgeyAuLi5jb25maWcsXG4gICAgLi4uZW1pdHRlcixcbiAgICBzdWJzY3JpcHRpb25cbiAgfSk7XG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGNhdGVnb3J5Q29kZTogJ2NvbmZpZ3MnLFxuICAgIGV2ZW50Q29kZTogJ3B1dCcsXG4gICAgY29uZmlnXG4gIH0pO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc3Vic2NyaXB0aW9uLnBpcGUodGFrZSgxKSwgdGltZW91dCg1MDAwKSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6ICgpID0+IHJlc29sdmUoeyAuLi5lbWl0dGVyLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgY29uZmlnXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgZXJyb3I6IGVycm9yID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgPT09ICdUaW1lb3V0IGhhcyBvY2N1cnJlZCcgPyBgQ29uZmlndXJhdGlvbiB3aXRoIHNjb3BlOiAke2NvbmZpZy5zY29wZX0gaGFzIGJlZW4gc2VudCB0byB0aGUgQmxvY2tuYXRpdmUgc2VydmVyLCBidXQgaGFzIG5vdCByZWNlaXZlZCBhIHJlcGx5IHdpdGhpbiA1IHNlY29uZHMuYCA6IGVycm9yLm1lc3NhZ2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJlc29sdmUoYEVycm9yOiAke21lc3NhZ2V9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUoc3Vic2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICBjaGFpbklkLFxuICAgIHR5cGVcbiAgfSA9IHN1YnNjcmlwdGlvbjtcblxuICBpZiAoIW5ldHdvcmtOYW1lKCdldGhlcmV1bScsIHBhcnNlSW50KGNoYWluSWQsIDE2KSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNoYWluSWQ6ICR7Y2hhaW5JZH0gaXMgYW4gdW5zdXBwb3J0ZWQgbmV0d29ya2ApO1xuICB9XG5cbiAgaWYgKCF0aGlzLmNvbm5lY3Rpb25zW2NoYWluSWRdKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uc1tjaGFpbklkXSA9IG5ldyB0aGlzLkJsb2NrbmF0aXZlKHtcbiAgICAgIHN5c3RlbTogJ2V0aGVyZXVtJyxcbiAgICAgIG5ldHdvcmtJZDogcGFyc2VJbnQoY2hhaW5JZCwgMTYpLFxuICAgICAgZGFwcElkOiB0aGlzLmFwaUtleSxcbiAgICAgIHdzOiB0aGlzLndzLFxuICAgICAgYXBpVXJsOiB0aGlzLmFwaVVybCxcbiAgICAgIHRyYW5zYWN0aW9uSGFuZGxlcnM6IFsoe1xuICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgfSkgPT4ge1xuICAgICAgICB0aGlzLm9uVHJhbnNhY3Rpb24kLm5leHQodHJhbnNhY3Rpb24pO1xuICAgICAgfV0sXG4gICAgICBvbmVycm9yOiBlcnJvciA9PiB0aGlzLmVycm9ycyQubmV4dChlcnJvcilcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHNkayA9IHRoaXMuY29ubmVjdGlvbnNbY2hhaW5JZF07XG5cbiAgaWYgKHR5cGUgPT09ICdhY2NvdW50Jykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlcnMgPSBbXSxcbiAgICAgIGFiaVxuICAgIH0gPSBzdWJzY3JpcHRpb247XG4gICAgc2RrLmNvbmZpZ3VyYXRpb24oe1xuICAgICAgc2NvcGU6IGlkLFxuICAgICAgZmlsdGVycyxcbiAgICAgIC4uLihhYmkgPyB7XG4gICAgICAgIGFiaVxuICAgICAgfSA6IHt9KSxcbiAgICAgIHdhdGNoQWRkcmVzczogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucyQucGlwZShmaWx0ZXIoKHtcbiAgICAgIHdhdGNoZWRBZGRyZXNzXG4gICAgfSkgPT4gd2F0Y2hlZEFkZHJlc3MgPT09IGlkKSwgZmluYWxpemUoKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGFpbklkXG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgZW1pdHRlclxuICAgIH0gPSBzZGsudHJhbnNhY3Rpb24oaWQpO1xuICAgIHJldHVybiBmcm9tRXZlbnQoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIC8vIEB0cy1pZ25vcmUgLSBzdHJpbmcgZG9lcyBub3QgbWF0Y2ggc3BlY2lmaWMgZXZlbnRjb2RlIHN0cmluZ1xuICAgIGVtaXR0ZXIsICdhbGwnKS5waXBlKCAvLyBhdXRvbWF0aWNhbGx5IGNvbXBsZXRlIHN0cmVhbSBvbiBhIGZpbmFsaXplZCBzdGF0dXNcbiAgICB0YWtlV2hpbGUoKHtcbiAgICAgIHN0YXR1c1xuICAgIH0pID0+IHN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgc3RhdHVzICE9PSAnZmFpbGVkJyAmJiBzdGF0dXMgIT09ICdkcm9wcGVkJywgdHJ1ZSksIC8vIGNsZWFudXAgc3Vic2NyaXB0aW9uIGFuZCBTREsgb24gY29tcGxldGlvblxuICAgIGZpbmFsaXplKCgpID0+IHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoe1xuICAgICAgICBpZCxcbiAgICAgICAgY2hhaW5JZFxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3Vic2NyaWJlJDEob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgaWQsXG4gICAgY2hhaW5JZCxcbiAgICB0aW1lb3V0ID0gMFxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGltZSQgPSB0aW1lcih0aW1lb3V0KTtcbiAgY29uc3QgdHJhbnNhY3Rpb25FdmVudCQgPSB0aGlzLnRyYW5zYWN0aW9ucyQucGlwZShmaWx0ZXIoKHtcbiAgICBoYXNoLFxuICAgIHdhdGNoZWRBZGRyZXNzXG4gIH0pID0+IGhhc2ggPT09IGlkIHx8IHdhdGNoZWRBZGRyZXNzID09PSBpZCkpO1xuICBtZXJnZSh0cmFuc2FjdGlvbkV2ZW50JCwgdGltZSQpLnBpcGUodGFrZSgxKSkgLy8gdGFrZSBqdXN0IGZpcnN0IGV2ZW50XG4gIC5zdWJzY3JpYmUocmVzID0+IHtcbiAgICAvLyBpZiBudW1iZXIsIHRoZW4gdGltZW91dCB3aXRoIG5vIHRyYW5zYWN0aW9uIGV2ZW50cywgc28gZ28gYWhlYWQgYW5kIHVuc3ViXG4gICAgaWYgKHR5cGVvZiByZXMgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25zdCBzZGtDb25uZWN0aW9ucyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuY29ubmVjdGlvbnMpLmZpbHRlcigoW2NoYWluSWQsIHNka10pID0+IHNkayAhPT0gbnVsbCk7XG4gICAgICBzZGtDb25uZWN0aW9ucy5mb3JFYWNoKChbY29ubmVjdGlvbkNoYWluSWQsIHNka10pID0+IHtcbiAgICAgICAgLy8gaWYgY2hhaW5JZCBpcyBwYXNzZWQgYW5kIGl0IGRvZXNuJ3QgbWF0Y2gsIHRoZW4gbm8gdW5zdWIgKHJldHVybiBlYXJseSlcbiAgICAgICAgaWYgKGNoYWluSWQgJiYgY29ubmVjdGlvbkNoYWluSWQgIT09IGNoYWluSWQpIHJldHVybjtcbiAgICAgICAgc2RrLnVuc3Vic2NyaWJlKGlkKTsgLy8gaWYgbm8gcmVtYWluaW5nIHN1YnNjcmlwdGlvbnMsIGRlc3Ryb3kgY29ubmVjdGlvbiBhbmQgc2V0IHRvIG51bGxcblxuICAgICAgICBpZiAoIXNkay53YXRjaGVkQWNjb3VudHMubGVuZ3RoICYmICFzZGsud2F0Y2hlZFRyYW5zYWN0aW9ucy5sZW5ndGggJiYgIXNkay5jb25maWd1cmF0aW9ucy5zaXplKSB7XG4gICAgICAgICAgc2RrLmRlc3Ryb3koKTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb25DaGFpbklkXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UgYSB0cmFuc2FjdGlvbiBldmVudCByZWNlaXZlZCwgc28gY2FsbCB1bnN1YiBhZ2FpbiBmb3IgYW5vdGhlciB0aW1lb3V0XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59IC8vKipFeHBlcmltZW50YWwgQVBJIHRoYXQgaXMgbm90IHlldCBmaW5hbGl6ZWQgYW5kIGlzIGluIEJFVEEqL1xuXG5cbmNsYXNzIE11bHRpQ2hhaW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBCbG9ja25hdGl2ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdzXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgYXBpS2V5XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgYXBpVXJsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgdGhpcy5hcGlVcmwgPSBhcGlVcmw7XG4gICAgdGhpcy53cyA9IHdzO1xuICAgIHRoaXMuY29ubmVjdGlvbnMgPSB7fTtcbiAgICB0aGlzLm9uVHJhbnNhY3Rpb24kID0gbmV3IFN1YmplY3QoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9ucyQgPSB0aGlzLm9uVHJhbnNhY3Rpb24kLmFzT2JzZXJ2YWJsZSgpO1xuICAgIHRoaXMuZXJyb3JzJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5CbG9ja25hdGl2ZSA9IEJsb2NrbmF0aXZlO1xuICAgIHRoaXMuc3Vic2NyaWJlID0gc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgdGhpcy51bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlJDEuYmluZCh0aGlzKTtcbiAgfVxuXG59XG5cbnZhciB2ZXJzaW9uID0gXCI0LjYuN1wiO1xuXG5mdW5jdGlvbiBzZW5kTWVzc2FnZShtc2cpIHtcbiAgaWYgKHRoaXMuX3F1ZXVlZE1lc3NhZ2VzLmxlbmd0aCA+IFFVRVVFX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBRdWV1ZSBsaW1pdCBvZiAke1FVRVVFX0xJTUlUfSBtZXNzYWdlcyBoYXMgYmVlbiByZWFjaGVkLmApO1xuICB9XG5cbiAgdGhpcy5fcXVldWVkTWVzc2FnZXMucHVzaChjcmVhdGVFdmVudExvZy5iaW5kKHRoaXMpKG1zZykpO1xuXG4gIGlmICghdGhpcy5fcHJvY2Vzc2luZ1F1ZXVlKSB7XG4gICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICB0aGlzLl9wcm9jZXNzaW5nUXVldWUgPSB0cnVlO1xuXG4gIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbm5lY3Rpb25PcGVuLmJpbmQodGhpcykoKTtcbiAgfVxuXG4gIHdoaWxlICh0aGlzLl9xdWV1ZWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gc21hbGwgd2FpdCB0byBhbGxvdyByZXNwb25zZSBmcm9tIHNlcnZlciB0byB0YWtlIGFmZmVjdFxuICAgIGF3YWl0IHdhaXQoMSk7XG5cbiAgICBpZiAodGhpcy5fd2FpdFRvUmV0cnkgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhdmUgYmVlbiByYXRlIGxpbWl0ZWQgc28gd2FpdFxuICAgICAgYXdhaXQgdGhpcy5fd2FpdFRvUmV0cnk7XG4gICAgICB0aGlzLl93YWl0VG9SZXRyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbXNnID0gdGhpcy5fcXVldWVkTWVzc2FnZXMuc2hpZnQoKTtcblxuICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5fbGltaXRSdWxlcy5kdXJhdGlvbiAvIHRoaXMuX2xpbWl0UnVsZXMucG9pbnRzICogMTAwMDtcbiAgICBhd2FpdCB3YWl0KGRlbGF5KTtcblxuICAgIHRoaXMuX3NvY2tldC5zZW5kKG1zZyk7XG4gIH1cblxuICB0aGlzLl9wcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgdGhpcy5fbGltaXRSdWxlcyA9IERFRkFVTFRfUkFURV9MSU1JVF9SVUxFUztcbn1cblxuZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtc2cpIHtcbiAgY29uc3Qge1xuICAgIHN0YXR1cyxcbiAgICByZWFzb24sXG4gICAgZXZlbnQsXG4gICAgY29ubmVjdGlvbklkLFxuICAgIHNlcnZlclZlcnNpb24sXG4gICAgcmV0cnlNcyxcbiAgICBsaW1pdFJ1bGVzLFxuICAgIGJsb2NrZWRNc2csXG4gICAgZGlzcGF0Y2hUaW1lc3RhbXBcbiAgfSA9IEpTT04ucGFyc2UobXNnLmRhdGEpO1xuXG4gIGlmIChjb25uZWN0aW9uSWQpIHtcbiAgICBpZiAoaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX3N0b3JhZ2VLZXksIGNvbm5lY3Rpb25JZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICB9IC8vIGhhbmRsZSBhbnkgZXJyb3JzIGZyb20gdGhlIHNlcnZlclxuXG5cbiAgaWYgKHN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ3JhdGVsaW1pdCcpICYmICFyZWFzb24ubWF0Y2goL0lQIChQZW5kaW5nU2ltdWxhdGlvbnxOb3RpZmljYXRpb24pIHJhdGVsaW1pdCByZWFjaGVkLykpIHtcbiAgICAgIHRoaXMuX3dhaXRUb1JldHJ5ID0gd2FpdChyZXRyeU1zKTtcbiAgICAgIHRoaXMuX2xpbWl0UnVsZXMgPSBsaW1pdFJ1bGVzOyAvLyBhZGQgYmxvY2tlZCBtc2cgdG8gdGhlIGZyb250IG9mIHRoZSBxdWV1ZVxuXG4gICAgICBibG9ja2VkTXNnICYmIHRoaXMuX3F1ZXVlZE1lc3NhZ2VzLnVuc2hpZnQoYmxvY2tlZE1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygndXBncmFkZSB5b3VyIHBsYW4nKSkge1xuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25vdCBhIHZhbGlkIEFQSSBrZXknKSkge1xuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25ldHdvcmsgbm90IHN1cHBvcnRlZCcpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygnbWF4aW11bSBhbGxvd2VkIGFtb3VudCcpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgYml0Y29pbiB0eGlkIGVycm9yXG5cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ2ludmFsaWQgdHhpZCcpKSB7XG4gICAgICBjb25zdCByZWFzb24gPSBgJHtldmVudC50cmFuc2FjdGlvbi50eGlkfSBpcyBhbiBpbnZhbGlkIHR4aWRgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgdHJhbnNhY3Rpb246IGV2ZW50LnRyYW5zYWN0aW9uLnR4aWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZXRoZXJldW0gdHJhbnNhY3Rpb24gaGFzaCBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdpbnZhbGlkIGhhc2gnKSkge1xuICAgICAgY29uc3QgcmVhc29uID0gYCR7ZXZlbnQudHJhbnNhY3Rpb24uaGFzaH0gaXMgYW4gaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoYDtcblxuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBldmVudC50cmFuc2FjdGlvbi5oYXNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGdlbmVyYWwgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdpbnZhbGlkIGFkZHJlc3MnKSkge1xuICAgICAgY29uc3QgcmVhc29uID0gYCR7ZXZlbnQuYWNjb3VudC5hZGRyZXNzfSBpcyBhbiBpbnZhbGlkIGFkZHJlc3NgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgYWNjb3VudDogZXZlbnQuYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGJpdGNvaW4gc3BlY2lmaWMgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdub3QgYSB2YWxpZCBCaXRjb2luJykpIHtcbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgICBhY2NvdW50OiBldmVudC5hY2NvdW50LmFkZHJlc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZXRoZXJldW0gc3BlY2lmaWMgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdub3QgYSB2YWxpZCBFdGhlcmV1bScpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgYWNjb3VudDogZXZlbnQuYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudCAmJiBldmVudC5jYXRlZ29yeUNvZGUgPT09ICdzaW11bGF0ZScpIHtcbiAgICAgIHNpbXVsYXRpb25zJC5lcnJvcih7XG4gICAgICAgIGV2ZW50SWQ6IGV2ZW50LmV2ZW50SWQsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaGFuZGxlIGNvbmZpZyBlcnJvclxuXG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY29uZmlnKSB7XG4gICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5jb25maWd1cmF0aW9ucy5nZXQoZXZlbnQuY29uZmlnLnNjb3BlKTtcblxuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgY29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdGhyb3cgZXJyb3IgdGhhdCBjb21lcyBiYWNrIGZyb20gdGhlIHNlcnZlciB3aXRob3V0IGZvcm1hdHRpbmcgdGhlIG1lc3NhZ2VcblxuXG4gICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChldmVudCAmJiBldmVudC5jb25maWcpIHtcbiAgICBjb25zdCBjYXNlZFNjb3BlID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gZXZlbnQuY29uZmlnLnNjb3BlLnRvTG93ZXJDYXNlKCkgOiBldmVudC5jb25maWcuc2NvcGU7XG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuY29uZmlndXJhdGlvbnMuZ2V0KGNhc2VkU2NvcGUpO1xuXG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24pIHtcbiAgICAgIGNvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXZlbnQgJiYgZXZlbnQudHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBldmVudElkLFxuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBldmVudENvZGUsXG4gICAgICBjb250cmFjdENhbGwsXG4gICAgICB0aW1lU3RhbXAsXG4gICAgICBibG9ja2NoYWluOiB7XG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgbmV0d29ya1xuICAgICAgfVxuICAgIH0gPSBldmVudDsgLy8gZmxhdHRlbiBpbiB0byBvbmUgb2JqZWN0XG5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IHsgLi4udHJhbnNhY3Rpb24sXG4gICAgICBzZXJ2ZXJWZXJzaW9uLFxuICAgICAgZXZlbnRDb2RlLFxuICAgICAgdGltZVN0YW1wLFxuICAgICAgZGlzcGF0Y2hUaW1lc3RhbXAsXG4gICAgICBzeXN0ZW0sXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RDYWxsXG4gICAgfSA6IHsgLi4udHJhbnNhY3Rpb24sXG4gICAgICBzZXJ2ZXJWZXJzaW9uLFxuICAgICAgZXZlbnRDb2RlLFxuICAgICAgdGltZVN0YW1wLFxuICAgICAgZGlzcGF0Y2hUaW1lc3RhbXAsXG4gICAgICBzeXN0ZW0sXG4gICAgICBuZXR3b3JrXG4gICAgfTsgLy8gaWdub3JlIHNlcnZlciBlY2hvIGFuZCB1bnN1YnNjcmliZSBtZXNzYWdlc1xuXG4gICAgaWYgKHNlcnZlckVjaG8oZXZlbnRDb2RlKSB8fCB0cmFuc2FjdGlvbi5zdGF0dXMgPT09ICd1bnN1YnNjcmliZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyByZXBsYWNlIG9yaWdpbmFsSGFzaCB0byBtYXRjaCB3ZWJob29rIEFQSVxuXG5cbiAgICBpZiAobmV3U3RhdGUub3JpZ2luYWxIYXNoKSB7XG4gICAgICBuZXdTdGF0ZS5yZXBsYWNlSGFzaCA9IG5ld1N0YXRlLmhhc2g7XG4gICAgICBuZXdTdGF0ZS5oYXNoID0gbmV3U3RhdGUub3JpZ2luYWxIYXNoO1xuICAgICAgZGVsZXRlIG5ld1N0YXRlLm9yaWdpbmFsSGFzaDtcbiAgICB9IC8vIHJlcGxhY2Ugc3RhdHVzIHRvIG1hdGNoIHdlYmhvb2sgQVBJXG5cblxuICAgIGlmIChldmVudENvZGUgPT09ICd0eFNwZWVkVXAnICYmIG5ld1N0YXRlLnN0YXR1cyAhPT0gJ3NwZWVkdXAnKSB7XG4gICAgICBuZXdTdGF0ZS5zdGF0dXMgPSAnc3BlZWR1cCc7XG4gICAgfSAvLyByZXBsYWNlIHN0YXR1cyB0byBtYXRjaCB3ZWJob29rIEFQSVxuXG5cbiAgICBpZiAoZXZlbnRDb2RlID09PSAndHhDYW5jZWwnICYmIG5ld1N0YXRlLnN0YXR1cyAhPT0gJ2NhbmNlbCcpIHtcbiAgICAgIG5ld1N0YXRlLnN0YXR1cyA9ICdjYW5jZWwnO1xuICAgIH0gLy8gaGFuZGxlIGNoYW5nZSBvZiBoYXNoIGluIHNwZWVkdXAgYW5kIGNhbmNlbCBldmVudHNcblxuXG4gICAgaWYgKGV2ZW50Q29kZSA9PT0gJ3R4U3BlZWRVcCcgfHwgZXZlbnRDb2RlID09PSAndHhDYW5jZWwnKSB7XG4gICAgICB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMgPSB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMubWFwKHR4ID0+IHtcbiAgICAgICAgaWYgKHR4Lmhhc2ggPT09IG5ld1N0YXRlLnJlcGxhY2VIYXNoKSB7XG4gICAgICAgICAgLy8gcmVhc3NpZ24gaGFzaCBwYXJhbWV0ZXIgaW4gdHJhbnNhY3Rpb24gcXVldWUgdG8gbmV3IGhhc2ggb3IgdHhpZFxuICAgICAgICAgIHR4Lmhhc2ggPSB0cmFuc2FjdGlvbi5oYXNoIHx8IHRyYW5zYWN0aW9uLnR4aWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHg7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY2F0ZWdvcnlDb2RlID09PSAnc2ltdWxhdGUnKSB7XG4gICAgICBuZXdTdGF0ZS5jb250cmFjdENhbGwgPSBldmVudC50cmFuc2FjdGlvbi5jb250cmFjdENhbGw7XG4gICAgICBkZWxldGUgbmV3U3RhdGUuZGlzcGF0Y2hUaW1lc3RhbXA7XG4gICAgICBzaW11bGF0aW9ucyQubmV4dCh7XG4gICAgICAgIGV2ZW50SWQsXG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2F0Y2hlZEFkZHJlc3MgPSB0cmFuc2FjdGlvbi53YXRjaGVkQWRkcmVzcyAmJiB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyB0cmFuc2FjdGlvbi53YXRjaGVkQWRkcmVzcy50b0xvd2VyQ2FzZSgpIDogdHJhbnNhY3Rpb24ud2F0Y2hlZEFkZHJlc3M7XG5cbiAgICBpZiAod2F0Y2hlZEFkZHJlc3MpIHtcbiAgICAgIGNvbnN0IGFjY291bnRPYmogPSB0aGlzLndhdGNoZWRBY2NvdW50cy5maW5kKGFjID0+IGFjLmFkZHJlc3MgPT09IHdhdGNoZWRBZGRyZXNzKTtcbiAgICAgIGNvbnN0IGFjY291bnRFbWl0dGVyUmVzdWx0ID0gYWNjb3VudE9iaiA/IGxhc3QoYWNjb3VudE9iai5lbWl0dGVycy5tYXAoZW1pdHRlciA9PiBlbWl0dGVyLmVtaXQobmV3U3RhdGUpKSkgOiBmYWxzZTtcbiAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLmdldCh3YXRjaGVkQWRkcmVzcyk7XG4gICAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmVtaXR0ZXIgPyBjb25maWd1cmF0aW9uLmVtaXR0ZXIuZW1pdChuZXdTdGF0ZSkgfHwgYWNjb3VudEVtaXR0ZXJSZXN1bHQgOiBhY2NvdW50RW1pdHRlclJlc3VsdDtcblxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgICAgZW1pdHRlclJlc3VsdFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbk9iaiA9IHRoaXMud2F0Y2hlZFRyYW5zYWN0aW9ucy5maW5kKHR4ID0+IHR4Lmhhc2ggPT09IG5ld1N0YXRlLmhhc2ggfHwgbmV3U3RhdGUudHhpZCk7XG4gICAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gdHJhbnNhY3Rpb25PYmogJiYgdHJhbnNhY3Rpb25PYmouZW1pdHRlci5lbWl0KG5ld1N0YXRlKTtcblxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgICAgZW1pdHRlclJlc3VsdFxuICAgICAgfSkpOyAvLyByZXBsYWNlIHRoZSBlbWl0dGVyIGhhc2ggdG8gdGhlIHJlcGxhY2UgaGFzaCBvbiByZXBsYWNlbWVudCB0eHNcblxuXG4gICAgICBpZiAobmV3U3RhdGUuc3RhdHVzID09PSAnc3BlZWR1cCcgfHwgbmV3U3RhdGUuc3RhdHVzID09PSAnY2FuY2VsJykge1xuICAgICAgICB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMgPSB0aGlzLndhdGNoZWRUcmFuc2FjdGlvbnMubWFwKHR4ID0+IHtcbiAgICAgICAgICBpZiAodHguaGFzaCA9PT0gbmV3U3RhdGUuaGFzaCB8fCBuZXdTdGF0ZS50eGlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi50eCxcbiAgICAgICAgICAgICAgaGFzaDogbmV3U3RhdGUucmVwbGFjZUhhc2hcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRMb2cobXNnKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgdGltZVN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgZGFwcElkOiB0aGlzLl9kYXBwSWQsXG4gICAgdmVyc2lvbixcbiAgICBhcHBOYW1lOiB0aGlzLl9hcHBOYW1lLFxuICAgIGFwcFZlcnNpb246IHRoaXMuX2FwcFZlcnNpb24sXG4gICAgYmxvY2tjaGFpbjoge1xuICAgICAgc3lzdGVtOiB0aGlzLl9zeXN0ZW0sXG4gICAgICBuZXR3b3JrOiBuZXR3b3JrTmFtZSh0aGlzLl9zeXN0ZW0sIHRoaXMuX25ldHdvcmtJZCkgfHwgJ2xvY2FsJ1xuICAgIH0sXG4gICAgLi4ubXNnXG4gIH0sIG1zZy5jYXRlZ29yeUNvZGUgPT09ICdjb25maWdzJyA/IGpzb25QcmVzZXJ2ZVVuZGVmaW5lZCA6IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JDb25uZWN0aW9uT3BlbigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3QgREVGQVVMVF9BUFBfTkFNRSA9ICd1bmtub3duJztcbmNvbnN0IERFRkFVTFRfQVBQX1ZFUlNJT04gPSAndW5rbm93bic7XG5jb25zdCBERUZBVUxUX1NZU1RFTSA9ICdldGhlcmV1bSc7XG5cbmNsYXNzIFNESyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3Qge1xuICAgICAgc3lzdGVtID0gREVGQVVMVF9TWVNURU0sXG4gICAgICBuYW1lID0gREVGQVVMVF9BUFBfTkFNRSxcbiAgICAgIGFwcFZlcnNpb24gPSBERUZBVUxUX0FQUF9WRVJTSU9OLFxuICAgICAgbmV0d29ya0lkLFxuICAgICAgdHJhbnNhY3Rpb25IYW5kbGVycyA9IFtdLFxuICAgICAgd3MsXG4gICAgICBvbm9wZW4sXG4gICAgICBvbmRvd24sXG4gICAgICBvbnJlb3BlbixcbiAgICAgIG9uZXJyb3IsXG4gICAgICBvbmNsb3NlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgYXBpVXJsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgZGFwcElkXG4gICAgfSA9IG9wdGlvbnM7IC8vIG92ZXJyaWRlIGRlZmF1bHQgdGltZW91dCB0byBhbGxvdyBmb3Igc2xvdyBjb25uZWN0aW9uc1xuXG4gICAgY29uc3QgdGltZW91dCA9IHtcbiAgICAgIGNvbm5lY3RUaW1lb3V0OiAxMDAwMFxuICAgIH07XG4gICAgY29uc3Qgc29ja2V0ID0gbmV3IFN0dXJkeVdlYlNvY2tldChhcGlVcmwgfHwgJ3dzczovL2FwaS5ibG9ja25hdGl2ZS5jb20vdjAnLCB3cyA/IHtcbiAgICAgIHdzQ29uc3RydWN0b3I6IHdzLFxuICAgICAgLi4udGltZW91dFxuICAgIH0gOiB7IC4uLnRpbWVvdXRcbiAgICB9KTtcbiAgICBzb2NrZXQub25vcGVuID0gb25PcGVuLmJpbmQodGhpcywgb25vcGVuKTtcbiAgICBzb2NrZXQub25kb3duID0gb25Eb3duLmJpbmQodGhpcywgb25kb3duKTtcbiAgICBzb2NrZXQub25yZW9wZW4gPSBvblJlb3Blbi5iaW5kKHRoaXMsIG9ucmVvcGVuKTtcbiAgICBzb2NrZXQub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZS5iaW5kKHRoaXMpO1xuXG4gICAgc29ja2V0Lm9uZXJyb3IgPSBlcnJvciA9PiBvbmVycm9yICYmIG9uZXJyb3Ioe1xuICAgICAgbWVzc2FnZTogJ1RoZXJlIHdhcyBhIFdlYlNvY2tldCBlcnJvcicsXG4gICAgICBlcnJvclxuICAgIH0pO1xuXG4gICAgc29ja2V0Lm9uY2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9waW5nVGltZW91dCAmJiBjbGVhckludGVydmFsKHRoaXMuX3BpbmdUaW1lb3V0KTtcbiAgICAgIG9uY2xvc2UgJiYgb25jbG9zZSgpO1xuICAgIH07XG5cbiAgICBjb25zdCBzdG9yYWdlS2V5ID0gQ3J5cHRvRXMuU0hBMShgJHtkYXBwSWR9IC0gJHtuYW1lfWApLnRvU3RyaW5nKCk7XG4gICAgY29uc3Qgc3RvcmVkQ29ubmVjdGlvbklkID0gaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUoKSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgdGhpcy5fc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgdGhpcy5fY29ubmVjdGlvbklkID0gc3RvcmVkQ29ubmVjdGlvbklkIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kYXBwSWQgPSBkYXBwSWQ7XG4gICAgdGhpcy5fc3lzdGVtID0gc3lzdGVtO1xuICAgIHRoaXMuX25ldHdvcmtJZCA9IG5ldHdvcmtJZDtcbiAgICB0aGlzLl9hcHBOYW1lID0gbmFtZTtcbiAgICB0aGlzLl9hcHBWZXJzaW9uID0gYXBwVmVyc2lvbjtcbiAgICB0aGlzLl90cmFuc2FjdGlvbkhhbmRsZXJzID0gdHJhbnNhY3Rpb25IYW5kbGVycztcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UgPSBzZW5kTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3BpbmdUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX29uZXJyb3IgPSBvbmVycm9yO1xuICAgIHRoaXMuX3F1ZXVlZE1lc3NhZ2VzID0gW107XG4gICAgdGhpcy5fbGltaXRSdWxlcyA9IERFRkFVTFRfUkFURV9MSU1JVF9SVUxFUztcbiAgICB0aGlzLl93YWl0VG9SZXRyeSA9IG51bGw7XG4gICAgdGhpcy5fcHJvY2Vzc2luZ1F1ZXVlID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvY2Vzc1F1ZXVlID0gcHJvY2Vzc1F1ZXVlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fc29ja2V0LndzLm9uKSB7XG4gICAgICB0aGlzLl9oZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLl9waW5nVGltZW91dCk7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgLy8gdGVybWluYXRlIGNvbm5lY3Rpb24gaWYgd2UgaGF2ZW4ndCBoZWFyZCB0aGUgc2VydmVyIHBpbmcgYWZ0ZXIgc2VydmVyIHRpbWVvdXQgcGx1cyBjb25zZXJ2YXRpdmUgbGF0ZW5jeSBkZWxheVxuICAgICAgICAgIC8vIFN0dXJkeSBXZWJzb2NrZXQgd2lsbCBoYW5kbGUgdGhlIG5ldyBjb25uZWN0aW9uIGxvZ2ljXG4gICAgICAgICAgdGhpcy5fc29ja2V0LndzLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9LCAzMDAwMCArIDEwMDApO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fc29ja2V0LndzLm9uKCdwaW5nJywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9oZWFydGJlYXQgJiYgdGhpcy5faGVhcnRiZWF0KCk7XG4gICAgICB9KTtcbiAgICB9IC8vIHB1YmxpYyBBUElcblxuXG4gICAgdGhpcy53YXRjaGVkVHJhbnNhY3Rpb25zID0gW107XG4gICAgdGhpcy53YXRjaGVkQWNjb3VudHMgPSBbXTtcbiAgICB0aGlzLmNvbmZpZ3VyYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNpbXVsYXRlID0gc2ltdWxhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm11bHRpU2ltID0gbXVsdGlTaW0uYmluZCh0aGlzKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcblxuICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTsgLy8gY2FsbCBvbmNsb3NlIG1hbnVhbGx5IGhlcmUgYXMgU3R1cmR5V2ViU29ja2V0IGRvZXNuJ3QgY3VycmVudGx5IHdvcmsgYXMgZXhwZWN0ZWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcGhpbGlwc29uL3N0dXJkeS13ZWJzb2NrZXQvaXNzdWVzLzVcblxuICAgICAgdGhpcy5fc29ja2V0Lm9uY2xvc2UoKTtcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIG11bHRpY2hhaW4ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTXVsdGlDaGFpbihvcHRpb25zLCB0aGlzKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIG9uT3BlbihoYW5kbGVyKSB7XG4gIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gIGNvbnN0IG1zZyA9IHtcbiAgICBjYXRlZ29yeUNvZGU6ICdpbml0aWFsaXplJyxcbiAgICBldmVudENvZGU6ICdjaGVja0RhcHBJZCcsXG4gICAgY29ubmVjdGlvbklkOiB0aGlzLl9jb25uZWN0aW9uSWRcbiAgfTsgLy8gc2VuZCB0aGlzIG1lc3NhZ2UgZGlyZWN0bHkgcmF0aGVyIHRoYW4gcHV0IGluIHF1ZXVlXG5cbiAgdGhpcy5fc29ja2V0LnNlbmQoY3JlYXRlRXZlbnRMb2cuYmluZCh0aGlzKShtc2cpKTtcblxuICB0aGlzLl9oZWFydGJlYXQgJiYgdGhpcy5faGVhcnRiZWF0KCk7XG4gIGhhbmRsZXIgJiYgaGFuZGxlcigpO1xufVxuXG5mdW5jdGlvbiBvbkRvd24oaGFuZGxlciwgY2xvc2VFdmVudCkge1xuICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIoY2xvc2VFdmVudCk7XG4gIH1cblxuICB0aGlzLl9waW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5fcGluZ1RpbWVvdXQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBvblJlb3BlbihoYW5kbGVyKSB7XG4gIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gIGNvbnN0IG1zZyA9IHtcbiAgICBjYXRlZ29yeUNvZGU6ICdpbml0aWFsaXplJyxcbiAgICBldmVudENvZGU6ICdjaGVja0RhcHBJZCcsXG4gICAgY29ubmVjdGlvbklkOiB0aGlzLl9jb25uZWN0aW9uSWRcbiAgfTtcblxuICB0aGlzLl9zb2NrZXQuc2VuZChjcmVhdGVFdmVudExvZy5iaW5kKHRoaXMpKG1zZykpOyAvLyByZS1yZWdpc3RlciBhbGwgY29uZmlndXJhdGlvbnMgb24gcmUtY29ubmVjdGlvblxuXG5cbiAgY29uc3QgY29uZmlndXJhdGlvbnMgPSBBcnJheS5mcm9tKHRoaXMuY29uZmlndXJhdGlvbnMudmFsdWVzKCkpOyAvLyByZWdpc3RlciBnbG9iYWwgY29uZmlnIGZpcnN0IGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZVxuXG4gIGNvbnN0IGdsb2JhbENvbmZpZ3VyYXRpb24gPSB0aGlzLmNvbmZpZ3VyYXRpb25zLmdldCgnZ2xvYmFsJyk7XG5cbiAgaWYgKGdsb2JhbENvbmZpZ3VyYXRpb24pIHtcbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbWl0dGVyLFxuICAgICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAgIC4uLmNvbmZpZ1xuICAgICAgfSA9IGdsb2JhbENvbmZpZ3VyYXRpb247XG4gICAgICBhd2FpdCB0aGlzLmNvbmZpZ3VyYXRpb24oY29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdFcnJvciByZS1zZW5kaW5nIGdsb2JhbCBjb25maWd1cmF0aW9uIHVwb24gcmVjb25uZWN0aW9uOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBhZGRyZXNzQ29uZmlndXJhdGlvbnMgPSBjb25maWd1cmF0aW9ucy5maWx0ZXIoKHtcbiAgICBzY29wZVxuICB9KSA9PiBzY29wZSAhPT0gJ2dsb2JhbCcpO1xuICBhZGRyZXNzQ29uZmlndXJhdGlvbnMuZm9yRWFjaChlbmhhbmNlZENvbmZpZyA9PiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGNvbnN0IHtcbiAgICAgIGVtaXR0ZXIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAuLi5jb25maWdcbiAgICB9ID0gZW5oYW5jZWRDb25maWc7XG5cbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBjYXRlZ29yeUNvZGU6ICdjb25maWdzJyxcbiAgICAgIGV2ZW50Q29kZTogJ3B1dCcsXG4gICAgICBjb25maWdcbiAgICB9KTtcbiAgfSk7IC8vIHJlLXJlZ2lzdGVyIGFsbCBhY2NvdW50cyB0byBiZSB3YXRjaGVkIGJ5IHNlcnZlciB1cG9uXG4gIC8vIHJlLWNvbm5lY3Rpb24gYXMgdGhleSBkb24ndCBnZXQgdHJhbnNmZXJyZWQgb3ZlciBhdXRvbWF0aWNhbGx5XG4gIC8vIHRvIHRoZSBuZXcgY29ubmVjdGlvbiBsaWtlIHR4IGhhc2hlcyBkb1xuXG4gIHRoaXMud2F0Y2hlZEFjY291bnRzLmZvckVhY2goYWNjb3VudCA9PiB7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgZXZlbnRDb2RlOiAnYWNjb3VudEFkZHJlc3MnLFxuICAgICAgY2F0ZWdvcnlDb2RlOiAnd2F0Y2gnLFxuICAgICAgYWNjb3VudDoge1xuICAgICAgICBhZGRyZXNzOiBhY2NvdW50LmFkZHJlc3NcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKGhhbmRsZXIpIHtcbiAgICBoYW5kbGVyKCk7XG4gIH1cblxuICBpZiAodGhpcy5fc29ja2V0LndzICYmIHRoaXMuX3NvY2tldC53cy5vbikge1xuICAgIC8vIG5lZWQgdG8gcmUtcmVnaXN0ZXIgcGluZyBldmVudCBzaW5jZSBuZXcgY29ubmVjdGlvblxuICAgIHRoaXMuX3NvY2tldC53cy5vbigncGluZycsICgpID0+IHtcbiAgICAgIHRoaXMuX2hlYXJ0YmVhdCAmJiB0aGlzLl9oZWFydGJlYXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2hlYXJ0YmVhdCgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNESztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bnc-sdk/dist/esm/index.js\n");

/***/ })

};
;